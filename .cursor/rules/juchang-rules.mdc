---
alwaysApply: true
---
# Role & Philosophy
You are the Lead Architect for "JuChang" (èšåœº), an LBS-based P2P social platform.
**Core Philosophy**: 
1. **Single Source of Truth**: The Database Schema (`@juchang/db`) defines the world.
2. **Zero Redundancy**: NEVER manually re-type a TypeBox definition if it originates from the DB. **Derive, don't Define.**
3. **Spec-First & SDK-Driven**: Code follows the OpenAPI contract. Clients usage follows Eden Treaty (Web) or Orval SDK (MiniProgram).

---

# ğŸ—ï¸ Monorepo Structure & Responsibilities

## 1. @juchang/db (The Single Source of Truth - V9.2 Integrated)
- **Tech**: Drizzle ORM (PostgreSQL + PostGIS) + `drizzle-typebox`.
- **Path**: `packages/db/src/schema/*.ts`
- **Architecture**: **11 å¼ æ•´åˆè¡¨** (ä» 13 å¼ ä¼˜åŒ–è€Œæ¥ï¼Œå‡å°‘ 15% å¤æ‚åº¦)
  - `users` (æ•´åˆè®¤è¯ä¿¡æ¯ + AI é¢åº¦åˆ†ç¦»)
  - `activities` (æ•´åˆç¾¤èŠçŠ¶æ€ + é‡åº†åœ°å½¢é€‚é… + å¹½çµé”šç‚¹)  
  - `participants` (å±¥çº¦ç¡®è®¤ + ç”³è¯‰æœºåˆ¶)
  - `chat_messages` (ç›´æ¥å…³è”æ´»åŠ¨ï¼Œæ— éœ€ chat_groups)
  - `feedbacks` (å·®è¯„åé¦ˆç³»ç»Ÿ)
  - `notifications` (é€šçŸ¥æ¨é€ç³»ç»Ÿ)
  - `transactions` (æ•´åˆ orders + payments æ”¯ä»˜é€»è¾‘)
  - `action_logs` (æ“ä½œå®¡è®¡æ—¥å¿—)
  - `enums` (æ‰€æœ‰æšä¸¾å®šä¹‰)
  - `relations` (è¡¨å…³ç³»å®šä¹‰)
  - `index.ts` (ç»Ÿä¸€å¯¼å‡º)
- **V9.2 æ ¸å¿ƒç‰¹æ€§**:
  - **é‡åº†åœ°å½¢é€‚é…**: `locationHint` å­—æ®µæ”¯æŒ 3D åœ°å½¢ä½ç½®å¤‡æ³¨
  - **AI é¢åº¦åˆ†ç¦»**: `aiCreateQuotaToday` + `aiSearchQuotaToday` åˆ†åˆ«ç®¡ç†
  - **å¹½çµé”šç‚¹å®Œæ•´æ”¯æŒ**: `isGhost` + `ghostAnchorType` + `ghostSuggestedType`
  - **æ•´åˆæ”¯ä»˜é€»è¾‘**: ä¸€ä¸ª `transactions` è¡¨æ›¿ä»£ `orders` + `payments`
- **Mandate**:
  - Define tables using snake_case columns.
  - **IMMEDIATELY export TypeBox Schemas** (`insert...Schema`, `select...Schema`) using `createInsertSchema` and `createSelectSchema` from `drizzle-typebox`.
  - **Refine Logic Here**: Add validation (min/max/regex) inside `createInsertSchema`.
  - **Integration Pattern**: æ•´åˆç›¸å…³è¡¨åˆ°ä¸»è¡¨ï¼Œå‡å°‘ JOIN å¤æ‚åº¦
    ```typescript
    // âœ… CORRECT: V9.2 æ•´åˆåçš„è¡¨ç»“æ„
    export const users = pgTable("users", {
      // è®¤è¯ä¿¡æ¯ç›´æ¥å­˜å‚¨ï¼Œæ— éœ€å•ç‹¬ user_auths è¡¨
      wxOpenId: varchar("wx_openid", { length: 128 }).notNull().unique(),
      lastLoginIp: varchar("last_login_ip", { length: 45 }),
      lastLoginAt: timestamp("last_login_at"),
      // AI é¢åº¦åˆ†ç¦»ç®¡ç†
      aiCreateQuotaToday: integer("ai_create_quota_today").default(3).notNull(),
      aiSearchQuotaToday: integer("ai_search_quota_today").default(10).notNull(),
    });
    
    export const activities = pgTable("activities", {
      // ç¾¤èŠçŠ¶æ€ç›´æ¥å­˜å‚¨ï¼Œæ— éœ€å•ç‹¬ chat_groups è¡¨
      chatStatus: varchar("chat_status", { length: 20 }).default("active").notNull(),
      chatArchivedAt: timestamp("chat_archived_at"),
      // é‡åº†åœ°å½¢ä½ç½®å¤‡æ³¨
      locationHint: varchar("location_hint", { length: 100 }),
      // å¹½çµé”šç‚¹å®Œæ•´æ”¯æŒ
      isGhost: boolean("is_ghost").default(false).notNull(),
      ghostAnchorType: varchar("ghost_anchor_type", { length: 20 }),
      ghostSuggestedType: activityTypeEnum("ghost_suggested_type"),
    });
    
    export const transactions = pgTable("transactions", {
      // æ•´åˆ orders + paymentsï¼Œä¸€è¡¨æå®šæ”¯ä»˜é€»è¾‘
      status: transactionStatusEnum("status").default("pending").notNull(),
      outTradeNo: varchar("out_trade_no", { length: 64 }).unique().notNull(),
      transactionId: varchar("transaction_id", { length: 64 }),
    });
    ```

## 2. apps/api (The Business Logic Gateway - V9.2 8-Module Design)
- **Tech**: ElysiaJS + `@elysiajs/swagger` + TypeBox (t).
- **Path**: `apps/api/src/modules/*`
- **Architecture**: **8 ä¸ªæ ¸å¿ƒæ¨¡å—** (é‡æ„ AIï¼Œæ–°å¢ chat/transactions)
  - `auth`: è®¤è¯æˆæƒ (æ•´åˆå¾®ä¿¡ç™»å½•)
  - `users`: ç”¨æˆ·ç®¡ç† (æ•´åˆè®¤è¯ä¿¡æ¯ + AI é¢åº¦)
  - `activities`: æ´»åŠ¨ç®¡ç† (æ•´åˆç¾¤èŠçŠ¶æ€ + åœ°å½¢å¤‡æ³¨)
  - `participants`: å‚ä¸ç®¡ç† (å±¥çº¦ç¡®è®¤ + ç”³è¯‰æœºåˆ¶)
  - `ai`: AI æœåŠ¡ (âŒç æ‰èŠå¤©ï¼Œâœ…ä¸“æ³¨è§£æ/æœç´¢)
  - `chat`: ç¾¤èŠæ¶ˆæ¯ (âœ…æ–°å¢ï¼Œç›´æ¥å…³è”æ´»åŠ¨)
  - `transactions`: æ”¯ä»˜äº¤æ˜“ (âœ…æ–°å¢ï¼Œæ•´åˆæ”¯ä»˜é€»è¾‘)
  - `dashboard`: æ•°æ®é¢æ¿ (ç®¡ç†åå°)
- **Structure**: Feature-based folder structure (following Elysia best practices):
  - `controller.ts`: Elysia instance as controller, handles HTTP routing
  - `service.ts`: Business logic functions, pure functions that work with database
  - `model.ts`: TypeBox schemas and types using `Static<typeof schema>`
- **V9.2 AI Module Changes**:
  - âŒ **åˆ é™¤**: `/ai/chat`, `/ai/stream` ç­‰èŠå¤©ç«¯ç‚¹
  - âœ… **æ–°å¢**: `/ai/parse` (æ„å›¾è§£æ), `/ai/search` (æ™ºèƒ½æœç´¢)
  - âœ… **é¢åº¦ç®¡ç†**: åˆ†åˆ«æ¶ˆè€— `aiCreateQuotaToday` å’Œ `aiSearchQuotaToday`
- **Mandate**:
  - **Controller**: HTTP routing and request/response handling
  - **Service**: Pure business logic functions, database operations
  - **Model**: Define TypeBox schemas in `model.ts`, use `Static<typeof schema>` for types
  - **Type Exports**: âŒ **FORBIDDEN** `export namespace`, âœ… **REQUIRED** direct type exports: `export type TypeName = Static<typeof schema>`
  - **Schema Derivation**: Derive from `@juchang/db` schemas, avoid manual re-typing
  - **OpenAPI**: Swagger plugin outputs JSON at `/doc/json` (no UI).
  - **Strict Responses**: Response types MUST match the TypeBox schema in route definition.

## 3. apps/miniprogram (The WeChat Client)
- **Tech**: Native Wechat (Skyline/WebView) + Vite + TS.
- **Mandate**:
  - **NO Manual Requests**: DO NOT use `wx.request` for business logic.
  - **Use SDK**: Import methods from `@/api/generated.ts` (Generated by Orval).
  - **Styling**: Use SCSS.

## 4. apps/admin (The Admin Console)
- **Tech**: Vite + React 19 + TanStack Router + TanStack React Query + Eden Treaty.
- **Path**: `apps/admin/src/features/*`
- **Structure**: Feature-based folder structure:
  - `index.tsx`: Feature page component
  - `data/schema.ts`: TypeBox schemas for frontend validation (NOT Zod)
  - `data/data.ts`: Static data (options, styles)
  - `data/users.ts`: API calls using Eden Treaty
  - `hooks/use-*.ts`: React Query hooks
  - `components/*`: Feature-specific components
- **API vs Mock Data Strategy**:
  - **DB-Backed Features**: Use Eden Treaty to call real API endpoints (users, activities, transactions, dashboard)
  - **Management Features**: Use mock data in `src/lib/mock-data.ts` until backend implementation is ready
  - **Hooks Pattern**: All hooks in `src/hooks/use-*.ts` should use React Query with either real API or mock data
  - **Mock Data Location**: `apps/admin/src/lib/mock-data.ts` - centralized mock data for all management features
- **CRITICAL: Page Layout Consistency**:
  - **ALL pages MUST follow the tasks page template pattern**
  - **Required Structure**:
    ```typescript
    export function FeaturePage() {
      return (
        <FeatureProvider>
          <Header fixed>
            <Search />
            <div className='ms-auto flex items-center space-x-4'>
              <ThemeSwitch />
              <ConfigDrawer />
              <ProfileDropdown />
            </div>
          </Header>

          <Main className='flex flex-1 flex-col gap-4 sm:gap-6'>
            <div className='flex flex-wrap items-end justify-between gap-2'>
              <div>
                <h2 className='text-2xl font-bold tracking-tight'>é¡µé¢æ ‡é¢˜</h2>
                <p className='text-muted-foreground'>é¡µé¢æè¿°</p>
              </div>
              <FeaturePrimaryButtons />
            </div>
            <FeatureTable />
          </Main>

          <FeatureDialogs />
        </FeatureProvider>
      )
    }
    ```
  - **Required Components**:
    - `FeatureProvider`: Context provider for state management
    - `FeaturePrimaryButtons`: Action buttons (refresh, filters, etc.)
    - `FeatureTable`: Main data table using TanStack Table
    - `FeatureDialogs`: All modal dialogs
    - `FeatureColumns`: Column definitions for the table
    - `FeatureTableToolbar`: Search and filter toolbar
  - **Table Pattern**: Use TanStack Table with DataTablePagination, NOT custom pagination
  - **State Management**: Use Context pattern for component communication
  - **Dialogs**: Centralized in FeatureDialogs component
- **API Architecture Principle**:
  - **API is Role-Agnostic**: API does NOT have admin-specific controllers. Permissions are handled at middleware level.
  - **No Admin Prefix**: âŒ FORBIDDEN: `admin-xxx.controller.ts`, âœ… CORRECT: `xxx.controller.ts`
  - **DB-Backed Only**: API controllers MUST have corresponding DB schema, model, and service layers
  - **Management Features**: Features without DB support (moderation queue, risk dashboard, etc.) use mock data in Admin frontend
- **Mandate**:
  - **Eden Treaty**: Use `import { api } from '@/lib/eden'` for type-safe API calls.
  - **React Query**: Use `useQuery` and `useMutation` for data fetching and mutations.
  - **Type Safety**: Eden Treaty provides full type inference from Elysia API.
  - **No Server Actions**: This is a pure SPA, all API calls go through Eden Treaty.
  - **TypeBox Only**: Use TypeBox for all schemas, NOT Zod.
  - **Layout Consistency**: MUST follow tasks page template pattern exactly.

## 5. apps/web (Deprecated - Use apps/admin)
- **Status**: Deprecated, migrated to `apps/admin`.
- **Note**: The old Next.js admin has been replaced with a Vite-based SPA for better DX and performance.

---

# ğŸ“¦ DB Schema Writing Guide

## Required Pattern for All Schema Files

Every schema file in `packages/db/src/schema/*.ts` MUST follow this pattern:

```typescript
import { pgTable, ... } from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-typebox";

// 1. Define the table
export const users = pgTable("users", {
  id: uuid("id").primaryKey().defaultRandom(),
  // ... other columns
});

// 2. Define relations (if needed)
export const usersRelations = relations(users, ({ many }) => ({
  // ... relations
}));

// 3. Export TypeBox Schemas (ä½¿ç”¨ drizzle-typebox)
export const insertUserSchema = createInsertSchema(users);
export const selectUserSchema = createSelectSchema(users);

// 4. Export TypeScript types (optional but recommended)
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
```

## Naming Convention

- **Insert Schema**: `insertXxxSchema` (e.g., `insertUserSchema`, `insertActivitySchema`)
- **Select Schema**: `selectXxxSchema` (e.g., `selectUserSchema`, `selectActivitySchema`)
- **Types**: `Xxx` for select type, `NewXxx` for insert type (e.g., `User`, `NewUser`)

---

# ğŸš« The "NO MANUAL TYPEBOX" Rule (CRITICAL)

**When defining API Inputs/Outputs:**
1.  **FORBIDDEN**: Creating a root-level `t.Object({ ... })` that mirrors a DB table.
    - *Wrong*: `const UserResponse = t.Object({ id: t.String(), nickname: t.String() });`
2.  **REQUIRED**: Derive from `@juchang/db` schemas.
    - *Right (Select)*: `import { selectUserSchema } from '@juchang/db';`
    - *Right (Partial)*: `t.Pick(selectUserSchema, ['id', 'nickname'])` or manually construct with `t.Object({ id: t.String(), nickname: t.String() })`
    - *Right (Computed)*: `t.Extend(selectUserSchema, { distance: t.Number() })` or manually construct
    - *Right (List)*: `t.Array(selectUserSchema);`

**Exception**: purely transient parameters (e.g., `lat/lng` query params, `page`, `limit`) can be manually defined.

---

# ğŸ“œ Spec-Coding Workflow

When implementing a feature (e.g., "Find Nearby Activities"):

1.  **DB Check**: Define/Update table in `@juchang/db`. Ensure `geometry` column exists. Export TypeBox schemas.
2.  **Service Logic**: Implement `findNearbyActivities({ lat, lng })` function in `@juchang/services` using PostGIS functions.
3.  **Contract Definition**:
    - In `apps/api`, define route using Elysia: `.get('/activities/nearby', handler, { query: ..., response: ... })`.
    - **Request**: `t.Object({ lat: t.Number(), lng: t.Number() })`.
    - **Response**: `t.Array(selectActivitySchema)` or derived schema.
4.  **Route Implementation**:
    - Call service function -> Return data (Elysia auto-serializes).
5.  **SDK Gen**: Run `bun run gen:api` to update miniprogram API code in `apps/miniprogram/src/api/`.

---

# ğŸ“ Coding Standards

- **Naming**:
  - Database: `snake_case` (e.g., `user_id`, `created_at`).
  - TypeScript/JSON: `camelCase` (e.g., `userId`, `createdAt`).
  - *Note*: Drizzle handles the mapping automatically.
- **Error Handling**:
  - Use Elysia's error handling or throw standard Error.
  - Standard Format: `{ code: number, msg: string, data?: any }`.
- **Package Manager**:
  - Use **Bun** for all operations: `bun install`, `bun run dev`, etc.
  - Lockfile: `bun.lockb` (binary, should be committed).

---

# ğŸ”§ Elysia Best Practice Example

## Folder Structure
```
apps/api/src/modules/
  users/
    user.controller.ts  # Controller (Elysia instance)
    user.service.ts     # Service (business logic)
    user.model.ts       # Model (TypeBox schemas)
```

## Model Example (model.ts)
```typescript
// Model - TypeBox schemas and types
import { Elysia, t, type Static } from 'elysia';
import { selectUserSchema } from '@juchang/db';

/**
 * Model Plugin
 * éµå¾ª Single Source of Truth åŸåˆ™ï¼š
 * - ä» DB schema æ´¾ç”Ÿå­—æ®µå®šä¹‰ï¼ˆä½¿ç”¨ t.Pick, t.Omit, t.Intersectï¼‰
 * - ç¬æ€å‚æ•°ï¼ˆå¦‚ passwordã€pageã€limitï¼‰å¯æ‰‹åŠ¨å®šä¹‰
 * - ä½¿ç”¨ Static<typeof schema> è‡ªåŠ¨æ¨å¯¼ç±»å‹
 */

// è·¯å¾„å‚æ•°ï¼ˆç¬æ€å‚æ•°ï¼Œæ‰‹åŠ¨å®šä¹‰ï¼‰
const IdParams = t.Object({
  id: t.String({ format: 'uuid' }),
});

// ç™»å½•è¯·æ±‚ï¼ˆä» DB schema æ´¾ç”Ÿ phoneNumberï¼Œæ‰‹åŠ¨å®šä¹‰ passwordï¼‰
const LoginRequest = t.Intersect([
  t.Pick(selectUserSchema, ['phoneNumber']),
  t.Object({
    password: t.String({ minLength: 8 }),
  }),
]);

// é”™è¯¯å“åº”ï¼ˆç¬æ€å‚æ•°ï¼Œæ‰‹åŠ¨å®šä¹‰ï¼‰
const ErrorResponse = t.Object({
  code: t.Number(),
  msg: t.String(),
});

// æ³¨å†Œåˆ° Elysia Model Plugin
export const userModel = new Elysia({ name: 'userModel' })
  .model({
    'user.idParams': IdParams,
    'user.login': LoginRequest,
    'user.error': ErrorResponse,
  });

// å¯¼å‡º TS ç±»å‹ï¼ˆä½¿ç”¨ Static<typeof schema> è‡ªåŠ¨æ¨å¯¼ï¼‰
// âŒ ç¦æ­¢ä½¿ç”¨ export namespaceï¼Œæ”¹ä¸ºç›´æ¥å¯¼å‡ºç±»å‹
export type IdParams = Static<typeof IdParams>;
export type LoginRequest = Static<typeof LoginRequest>;
export type ErrorResponse = Static<typeof ErrorResponse>;
```

## Service Example (service.ts)
```typescript
// Service - Pure function, no HTTP dependencies
import { db, users, eq } from '@juchang/db';
import type { ErrorResponse } from './user.model';

export async function getUserById(id: string) {
  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.id, id))
    .limit(1);
  
  return user || null;
}
```

## Controller Example (controller.ts)
```typescript
// Controller - Elysia instance as controller
import { Elysia } from 'elysia';
import { selectUserSchema } from '@juchang/db';
import { userModel, type ErrorResponse } from './user.model';
import { getUserById } from './user.service';

export const userController = new Elysia({ prefix: '/users' })
  .use(userModel) // å¼•å…¥ Model Plugin
  .get(
    '/:id',
    async ({ params, set }) => {
      const user = await getUserById(params.id);
      
      if (!user) {
        set.status = 404;
        return {
          code: 404,
          msg: 'ç”¨æˆ·ä¸å­˜åœ¨',
        } satisfies ErrorResponse;
      }
      
      return user;
    },
    {
      detail: {
        tags: ['Users'],
        summary: 'è·å–ç”¨æˆ·è¯¦æƒ…',
      },
      params: 'user.idParams', // å¼•ç”¨ Model Plugin ä¸­æ³¨å†Œçš„ schema
      response: {
        200: selectUserSchema, // ç›´æ¥ä½¿ç”¨ DB schema
        404: 'user.error',     // å¼•ç”¨ Model Plugin ä¸­æ³¨å†Œçš„ schema
      },
    }
  );
```

## Schema Derivation Patterns

### 1. ç›´æ¥ä½¿ç”¨ DB Schema
```typescript
// âœ… æ­£ç¡®ï¼šç›´æ¥ä½¿ç”¨
response: {
  200: selectUserSchema,
}
```

### 2. é€‰æ‹©éƒ¨åˆ†å­—æ®µï¼ˆPickï¼‰
```typescript
// âœ… æ­£ç¡®ï¼šä» DB schema é€‰æ‹©å­—æ®µ
const UserSummary = t.Pick(selectUserSchema, ['id', 'nickname', 'avatarUrl']);
```

### 3. æ’é™¤å­—æ®µï¼ˆOmitï¼‰
```typescript
// âœ… æ­£ç¡®ï¼šæ’é™¤æ•æ„Ÿå­—æ®µ
const PublicUser = t.Omit(selectUserSchema, ['phoneNumber', 'wxOpenId']);
```

### 4. æ‰©å±•å­—æ®µï¼ˆIntersectï¼‰
```typescript
// âœ… æ­£ç¡®ï¼šç»„åˆ DB schema å’Œè‡ªå®šä¹‰å­—æ®µ
const UserWithDistance = t.Intersect([
  selectUserSchema,
  t.Object({
    distance: t.Number(), // è®¡ç®—å­—æ®µ
  }),
]);
```

### 5. ç»„åˆå¤šä¸ª Schema
```typescript
// âœ… æ­£ç¡®ï¼šç»„åˆå¤šä¸ªæ´¾ç”Ÿ schema
const LoginRequest = t.Intersect([
  t.Pick(selectUserSchema, ['phoneNumber']), // ä» DB æ´¾ç”Ÿ
  t.Object({
    password: t.String(), // ç¬æ€å‚æ•°
  }),
]);
```

### 6. æ•°ç»„å“åº”
```typescript
// âœ… æ­£ç¡®ï¼šæ•°ç»„å“åº”
const UserListResponse = t.Object({
  data: t.Array(selectUserSchema),
  total: t.Number(),
});
```

## Model Plugin ä½¿ç”¨è§„èŒƒ

### æ³¨å†Œ Schema
```typescript
// model.ts
export const userModel = new Elysia({ name: 'userModel' })
  .model({
    'user.idParams': IdParams,        // ä½¿ç”¨å‘½åç©ºé—´å‰ç¼€é¿å…å†²çª
    'user.login': LoginRequest,
    'user.error': ErrorResponse,
  });
```

### åœ¨ Controller ä¸­å¼•ç”¨
```typescript
// controller.ts
export const userController = new Elysia({ prefix: '/users' })
  .use(userModel) // å¿…é¡»å…ˆ use Model Plugin
  .get(
    '/:id',
    handler,
    {
      params: 'user.idParams',  // ä½¿ç”¨å­—ç¬¦ä¸²å¼•ç”¨æ³¨å†Œçš„ schema
      response: {
        200: selectUserSchema,  // å¯ä»¥ç›´æ¥ä½¿ç”¨ DB schema
        404: 'user.error',      // æˆ–ä½¿ç”¨å­—ç¬¦ä¸²å¼•ç”¨æ³¨å†Œçš„ schema
      },
    }
  );
```

### ç±»å‹å¯¼å‡ºè§„èŒƒ
```typescript
// âŒ é”™è¯¯ï¼šä½¿ç”¨ namespace
export namespace UserModel {
  export type idParams = Static<typeof IdParams>;
}

// âœ… æ­£ç¡®ï¼šç›´æ¥å¯¼å‡ºç±»å‹
export type IdParams = Static<typeof IdParams>;
export type ErrorResponse = Static<typeof ErrorResponse>;
```

### åœ¨ Service ä¸­ä½¿ç”¨ç±»å‹
```typescript
// service.ts
import type { ErrorResponse, IdParams } from './user.model';

// ç±»å‹å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€é€šè¿‡ namespace
function handleError(): ErrorResponse {
  return { code: 404, msg: 'Not found' };
}
```

---

# ğŸ¯ Admin Hooks Pattern (Mock Data vs Real API)

## Hook Categories

### 1. DB-Backed Hooks (Real API)
These hooks call real API endpoints that have full DB support:
```typescript
// apps/admin/src/hooks/use-users.ts - Real API
import { api, apiCall } from '@/lib/eden'

export function useUsers(filters = {}) {
  return useQuery({
    queryKey: ['users', filters],
    queryFn: () => apiCall(() => api.users.get({ query: filters })),
  })
}
```

**DB-Backed Features**: users, activities, transactions, participants, chat, dashboard

### 2. Mock Data Hooks (Management Features)
These hooks use mock data for features without backend implementation:
```typescript
// apps/admin/src/hooks/use-moderation.ts - Mock Data
import { mockModerationQueue, mockModerationStats } from '@/lib/mock-data'

export function useModerationQueue(filters = {}) {
  return useQuery({
    queryKey: ['moderation', 'queue', filters],
    queryFn: async () => mockModerationQueue,
    staleTime: 5 * 60 * 1000,
  })
}

export function useApproveContent() {
  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: async ({ id, action }) => {
      await new Promise(resolve => setTimeout(resolve, 500)) // Simulate API
      return { success: true, id, action }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['moderation'] })
      toast.success('æ“ä½œæˆåŠŸ')
    },
  })
}
```

**Mock Data Features**: moderation, risk-management, premium-services, geography-management, communication-management, system-management

### 3. Mock Data File Structure
```typescript
// apps/admin/src/lib/mock-data.ts
export const mockModerationQueue = { data: [...], total: 0 }
export const mockModerationStats = { pending: 0, approved: 0, ... }
export const mockRiskStats = { highRisk: 0, mediumRisk: 0, ... }
export const mockPremiumStats = { totalMembers: 0, revenue: 0, ... }
// ... more mock data
```

### 4. Migration Path
When backend implementation is ready:
1. Create DB schema in `@juchang/db`
2. Create API controller with model/service
3. Update hook to use `apiCall()` instead of mock data
4. Remove corresponding mock data from `mock-data.ts`

---

# ğŸ¤– Instruction for AI Generation (V9.2 Updated)

When I ask for a feature:
1.  **Plan**: Analyze `@juchang/db` first. Do we need new columns? Consider V9.2 integrated tables.
2.  **Schema**: Show me the `drizzle-typebox` derivation strategy (e.g., "I'll use `t.Pick(selectUserSchema, ['id', 'nickname'])`" or "I'll manually construct with `t.Object()`").
3.  **Service**: Write pure function (not class): `export async function getUserById(id: string) { ... }`
4.  **API**: Write the Elysia route with TypeBox schemas. Use correct V9.2 module (auth/users/activities/participants/ai/chat/transactions/dashboard).
5.  **AI Features**: 
   - âŒ **Never create** `/ai/chat` or streaming endpoints
   - âœ… **Always use** `/ai/parse` for activity creation, `/ai/search` for map search
   - âœ… **Always check** and consume appropriate AI quota (`aiCreateQuotaToday` or `aiSearchQuotaToday`)
6.  **Frontend**: If asked for UI, show how to call the **Eden Treaty** (Admin) or **Orval SDK** (MiniProgram), not raw fetch.
7.  **Admin Feature**: For admin features, create React Query hooks in `hooks/use-*.ts` and use them in components.
8.  **V9.2 Specific**:
   - **é‡åº†åœ°å½¢**: Always include `locationHint` for activity creation
   - **å¹½çµé”šç‚¹**: Use `isGhost`, `ghostAnchorType`, `ghostSuggestedType` fields
   - **æ•´åˆè¡¨**: Leverage integrated tables (users with auth, activities with chat status, transactions for payments)

---

# âš ï¸ Important Notes (V9.2 Updated)

- **TypeBox vs Zod**: We use TypeBox (t) from Elysia, NOT Zod (z). TypeBox is 50x faster.
- **Elysia vs Hono**: We use ElysiaJS, NOT Hono. Elysia is optimized for Bun.
- **Bun Runtime**: All scripts use `bun run`, not `npm` or `pnpm`.
- **Function-Based Services**: Services are pure functions, not classes.
- **Eden Treaty**: Admin uses Eden Treaty for type-safe API calls (zero code generation).
- **Orval SDK**: MiniProgram uses Orval-generated SDK (because Proxy is not supported).
- **Admin Stack**: Vite + React 19 + TanStack Router + TanStack React Query + shadcn/ui.
- **V9.2 Architecture**:
  - **11 å¼ æ•´åˆè¡¨**: ä» 13 å¼ ä¼˜åŒ–è€Œæ¥ï¼Œå‡å°‘ 15% å¤æ‚åº¦ (å®é™…å®ç°)
  - **8 ä¸ª API æ¨¡å—**: é‡æ„ AIï¼Œæ–°å¢ chat/transactions
  - **AI åŠŸèƒ½é‡å®šä½**: ä»ç‹¬ç«‹èŠå¤©è½¬å‘ä¸šåŠ¡åœºæ™¯é›†æˆ
  - **é‡åº†æœ¬åœ°åŒ–**: å¼ºåˆ¶ `locationHint`ï¼Œæ”¯æŒ 3D åœ°å½¢
  - **å¹½çµé”šç‚¹**: å®Œæ•´çš„å†·å¯åŠ¨è¿è¥æ”¯æŒ
  - **æ”¯ä»˜æ•´åˆ**: ä¸€ä¸ª `transactions` è¡¨æ›¿ä»£ `orders` + `payments`

---

# ğŸ¯ V9.2 Specific Development Patterns

## AI Integration Patterns

### âœ… Correct: AI as Business Tool
```typescript
// AI æ„å›¾è§£æ - èå…¥åˆ›å»ºæ´»åŠ¨æµç¨‹
export async function parseActivityIntent(input: string, userId: string) {
  // 1. æ£€æŸ¥é¢åº¦
  const user = await getUserById(userId);
  if (user.aiCreateQuotaToday <= 0) {
    throw new Error('AI å»ºå±€é¢åº¦å·²ç”¨å®Œ');
  }

  // 2. è°ƒç”¨ LLM
  const result = await callLLM({ input, schema: activitySchema });

  // 3. æ‰£é™¤é¢åº¦
  await consumeAIQuota(userId, 'create');

  return result;
}

// AI æ™ºèƒ½æœç´¢ - èå…¥åœ°å›¾æœç´¢æµç¨‹
export async function searchActivitiesWithAI(query: string, location: [number, number], userId: string) {
  // 1. æ£€æŸ¥é¢åº¦
  const user = await getUserById(userId);
  if (user.aiSearchQuotaToday <= 0) {
    throw new Error('AI æœç´¢é¢åº¦å·²ç”¨å®Œ');
  }

  // 2. PostGIS + AI è¯­ä¹‰æœç´¢
  const activities = await searchNearbyActivities(location, query);

  // 3. æ‰£é™¤é¢åº¦
  await consumeAIQuota(userId, 'search');

  return activities;
}
```

### âŒ Wrong: AI as Chat Service
```typescript
// âŒ ç¦æ­¢ï¼šç‹¬ç«‹çš„ AI èŠå¤©æœåŠ¡
export async function chatWithAI(message: string, conversationId: string) {
  // è¿™ç§å¼€æ”¾å¼èŠå¤©ä¼šæµªè´¹ Tokenï¼Œä¸”ä¸ä¸šåŠ¡åœºæ™¯è„±èŠ‚
}

// âŒ ç¦æ­¢ï¼šæµå¼èŠå¤©ç«¯ç‚¹
app.get('/ai/stream', async ({ query }) => {
  // ä¸è¦å®ç°æµå¼èŠå¤©åŠŸèƒ½
});
```

## Database Integration Patterns

### âœ… Correct: Leveraging Integrated Tables
```typescript
// åˆ©ç”¨æ•´åˆåçš„ users è¡¨
export async function getUserWithAuthInfo(id: string) {
  return await db.select({
    id: users.id,
    nickname: users.nickname,
    // è®¤è¯ä¿¡æ¯ç›´æ¥å¯ç”¨ï¼Œæ— éœ€ JOIN
    lastLoginAt: users.lastLoginAt,
    lastLoginIp: users.lastLoginIp,
    // AI é¢åº¦ç›´æ¥å¯ç”¨
    aiCreateQuota: users.aiCreateQuotaToday,
    aiSearchQuota: users.aiSearchQuotaToday,
  }).from(users).where(eq(users.id, id));
}

// åˆ©ç”¨æ•´åˆåçš„ activities è¡¨
export async function getActivityWithChatStatus(id: string) {
  return await db.select({
    ...activities,
    // ç¾¤èŠçŠ¶æ€ç›´æ¥å¯ç”¨ï¼Œæ— éœ€ JOIN chat_groups
    chatStatus: activities.chatStatus,
    chatArchivedAt: activities.chatArchivedAt,
    // é‡åº†åœ°å½¢ä¿¡æ¯
    locationHint: activities.locationHint,
    // å¹½çµé”šç‚¹ä¿¡æ¯
    isGhost: activities.isGhost,
    ghostAnchorType: activities.ghostAnchorType,
  }).from(activities).where(eq(activities.id, id));
}
```

### âŒ Wrong: Old Multi-Table JOINs
```typescript
// âŒ é”™è¯¯ï¼šå°è¯• JOIN å·²ç»æ•´åˆçš„è¡¨
export async function getUserWithAuth(id: string) {
  // user_auths è¡¨å·²ç»ä¸å­˜åœ¨äº†
  return await db.select()
    .from(users)
    .leftJoin(userAuths, eq(users.id, userAuths.userId)) // âŒ è¡¨ä¸å­˜åœ¨
    .where(eq(users.id, id));
}
```

## Payment Integration Patterns

### âœ… Correct: Using Integrated Transactions
```typescript
// åˆ›å»ºæ”¯ä»˜è®¢å• - ä½¿ç”¨æ•´åˆçš„ transactions è¡¨
export async function createPaymentOrder(data: {
  userId: string;
  productType: 'boost' | 'pin_plus' | 'fast_pass';
  amount: number;
  relatedId?: string;
}) {
  const outTradeNo = generateTradeNo();
  
  const transaction = await db.insert(transactions).values({
    userId: data.userId,
    productType: data.productType,
    productName: getProductName(data.productType),
    amount: data.amount,
    outTradeNo,
    relatedId: data.relatedId,
    status: 'pending',
  }).returning();

  // è°ƒç”¨å¾®ä¿¡æ”¯ä»˜ API
  const wxPayResult = await createWxPayOrder({
    outTradeNo,
    amount: data.amount,
    description: transaction.productName,
  });

  return { transaction, wxPayResult };
}

// æ”¯ä»˜å›è°ƒå¤„ç† - åŸå­æ€§æ›´æ–°
export async function handlePaymentCallback(callbackData: WxPayCallback) {
  return await db.transaction(async (tx) => {
    // 1. æ›´æ–°äº¤æ˜“çŠ¶æ€
    await tx.update(transactions)
      .set({
        status: 'paid',
        transactionId: callbackData.transaction_id,
        callbackData: callbackData,
        paidAt: new Date(),
      })
      .where(eq(transactions.outTradeNo, callbackData.out_trade_no));

    // 2. ä¸‹å‘æƒç›Š
    const transaction = await tx.select().from(transactions)
      .where(eq(transactions.outTradeNo, callbackData.out_trade_no));
    
    await grantPremiumService(transaction[0], tx);
  });
}
```

## Chongqing Terrain Adaptation

### âœ… Correct: Location Hint Integration
```typescript
// åˆ›å»ºæ´»åŠ¨æ—¶å¼ºåˆ¶ä½ç½®å¤‡æ³¨
export const createActivitySchema = t.Intersect([
  t.Pick(insertActivitySchema, ['title', 'description', 'type']),
  t.Object({
    location: t.Object({
      lat: t.Number(),
      lng: t.Number(),
    }),
    locationName: t.String(),
    locationHint: t.String({ 
      minLength: 1,
      description: 'ä½ç½®å¤‡æ³¨ï¼ˆå¿…å¡«ï¼‰ï¼šå¦‚ 4æ¥¼å¹³å°ã€åœ°ä¸‹B1å±‚ã€è½»è½¨3å·å‡ºå£ç­‰'
    }),
  }),
]);

// åœ°å›¾æ˜¾ç¤ºæ—¶åŒ…å«ä½ç½®å¤‡æ³¨
export async function getActivitiesForMap(bounds: MapBounds) {
  return await db.select({
    id: activities.id,
    title: activities.title,
    location: activities.location,
    locationName: activities.locationName,
    locationHint: activities.locationHint, // é‡åº†åœ°å½¢å¤‡æ³¨
    type: activities.type,
    currentParticipants: activities.currentParticipants,
    maxParticipants: activities.maxParticipants,
  }).from(activities)
  .where(and(
    eq(activities.status, 'published'),
    sql`ST_Within(${activities.location}, ST_MakeEnvelope(${bounds.sw.lng}, ${bounds.sw.lat}, ${bounds.ne.lng}, ${bounds.ne.lat}, 4326))`
  ));
}
```

## Ghost Anchor Patterns

### âœ… Correct: Complete Ghost Anchor Support
```typescript
// åˆ›å»ºå¹½çµé”šç‚¹
export async function createGhostAnchor(data: {
  location: [number, number];
  anchorType: 'demand' | 'promotion';
  suggestedType: ActivityType;
  locationHint: string;
}) {
  return await db.insert(activities).values({
    title: generateAnchorTitle(data.suggestedType),
    description: generateAnchorDescription(data.suggestedType),
    location: sql`ST_GeomFromText('POINT(${data.location[0]} ${data.location[1]})', 4326)`,
    locationName: 'å¾…å®š',
    locationHint: data.locationHint,
    type: data.suggestedType,
    startAt: new Date(),
    
    // å¹½çµé”šç‚¹æ ‡è®°
    isGhost: true,
    ghostAnchorType: data.anchorType,
    ghostSuggestedType: data.suggestedType,
    
    // é»˜è®¤å€¼
    creatorId: SYSTEM_USER_ID,
    status: 'published',
    maxParticipants: 4,
  });
}

// ç‚¹å‡»å¹½çµé”šç‚¹çš„å¤„ç†
export async function handleGhostAnchorClick(anchorId: string, userId: string) {
  const anchor = await db.select().from(activities)
    .where(and(
      eq(activities.id, anchorId),
      eq(activities.isGhost, true)
    ));

  if (!anchor.length) {
    throw new Error('é”šç‚¹ä¸å­˜åœ¨');
  }

  // å¤ç”¨ AI æ„å›¾è§£ææµç¨‹ï¼Œé¢„å¡«ä¿¡æ¯
  return {
    prefilled: {
      type: anchor[0].ghostSuggestedType,
      location: anchor[0].location,
      locationName: anchor[0].locationName,
      locationHint: anchor[0].locationHint,
    },
    suggestions: [
      `åœ¨${anchor[0].locationName}ç»„ç»‡${getTypeLabel(anchor[0].ghostSuggestedType)}æ´»åŠ¨`,
      `è¿™é‡Œå¾ˆé€‚åˆ${getTypeLabel(anchor[0].ghostSuggestedType)}ï¼Œè¦ä¸è¦è¯•è¯•ï¼Ÿ`,
    ],
  };
}
```

---

# ğŸ“‹ V9.2 Development Checklist

## When Creating New Features

### Database Changes
- [ ] è€ƒè™‘æ˜¯å¦å¯ä»¥åˆ©ç”¨ç°æœ‰çš„ 9 å¼ æ•´åˆè¡¨
- [ ] å¦‚éœ€æ–°å­—æ®µï¼Œä¼˜å…ˆæ·»åŠ åˆ°ä¸»è¡¨è€Œéåˆ›å»ºæ–°è¡¨
- [ ] ä½¿ç”¨ `drizzle-typebox` è‡ªåŠ¨ç”Ÿæˆ TypeBox Schema
- [ ] ä¸ºé‡åº†åœ°å½¢ç›¸å…³åŠŸèƒ½æ·»åŠ  `locationHint` æ”¯æŒ

### API Development
- [ ] ç¡®å®šåŠŸèƒ½å±äºå“ªä¸ªæ¨¡å— (auth/users/activities/participants/ai/chat/transactions/dashboard)
- [ ] AI åŠŸèƒ½å¿…é¡»æ£€æŸ¥å¹¶æ¶ˆè€—å¯¹åº”é¢åº¦
- [ ] ä» `@juchang/db` æ´¾ç”Ÿ TypeBox Schemaï¼Œç¦æ­¢æ‰‹åŠ¨å®šä¹‰
- [ ] ä½¿ç”¨çº¯å‡½æ•°å®ç° Service å±‚
- [ ] é”™è¯¯å“åº”ä½¿ç”¨ç»Ÿä¸€æ ¼å¼ `{ code, msg, data? }`

### Frontend Integration
- [ ] Admin ä½¿ç”¨ Eden Treaty + React Query
- [ ] MiniProgram ä½¿ç”¨ Orval ç”Ÿæˆçš„ SDK
- [ ] é‡åº†åœ°å½¢åŠŸèƒ½å¿…é¡»æ˜¾ç¤º `locationHint`
- [ ] å¹½çµé”šç‚¹ç‚¹å‡»åå¤ç”¨ AI è§£ææµç¨‹

### Testing & Validation
- [ ] æµ‹è¯•æ•´åˆè¡¨çš„æŸ¥è¯¢æ€§èƒ½
- [ ] éªŒè¯ AI é¢åº¦æ‰£é™¤é€»è¾‘
- [ ] ç¡®è®¤æ”¯ä»˜å›è°ƒçš„åŸå­æ€§
- [ ] æ£€æŸ¥é‡åº†åœ°å½¢å¤‡æ³¨çš„å¿…å¡«éªŒè¯
