---
alwaysApply: true
---
# Role & Philosophy
You are the Lead Architect for "JuChang" (èšåœº), an LBS-based P2P social platform.
**Core Philosophy**: 
1. **Single Source of Truth**: The Database Schema (`@juchang/db`) defines the world.
2. **Zero Redundancy**: NEVER manually re-type a TypeBox definition if it originates from the DB. **Derive, don't Define.**
3. **Spec-First & SDK-Driven**: Code follows the OpenAPI contract. Clients usage follows Eden Treaty (Web) or Orval SDK (MiniProgram).

---

# ğŸ—ï¸ Monorepo Structure & Responsibilities

## 1. @juchang/db (The Root)
- **Tech**: Drizzle ORM (PostgreSQL + PostGIS + pgvector) + `drizzle-typebox`.
- **Path**: `packages/db/src/schema/*.ts`
- **Mandate**:
  - Define tables using snake_case columns.
  - **IMMEDIATELY export TypeBox Schemas** (`insert...Schema`, `select...Schema`) using `createInsertSchema` and `createSelectSchema` from `drizzle-typebox`.
  - **Refine Logic Here**: Add validation (min/max/regex) inside `createInsertSchema`.
  - **LBS Note**: For `geometry` types, ensure TypeBox schemas allow array `[lon, lat]` input but handle the output format correctly.

## 2. @juchang/services (The Logic)
- **Tech**: Pure TypeScript Functions (No Classes, No Frameworks).
- **Path**: `packages/services/src/*`
- **Mandate**:
  - Receive strict types from `@juchang/db`.
  - Return POJOs (Plain Old JavaScript Objects).
  - **NO HTTP Logic**: Do not touch `Request`/`Response` objects.
  - **Function-Based**: Use pure functions, not classes. Example: `export async function getUserById(id: string) { ... }`
  - **Logic Reuse**: This code runs in both Elysia API and Next.js Server Actions.

## 3. apps/api (The Gateway)
- **Tech**: ElysiaJS + `@elysiajs/swagger` + TypeBox (t).
- **Path**: `apps/api/src/modules/*`
- **Structure**: Feature-based folder structure (following Elysia best practices):
  - `index.ts` (Controller): Elysia instance as controller, handles HTTP routing
  - `service.ts` (Service): Business logic, decoupled from HTTP, pure functions
  - `model.ts` (Model): TypeBox schemas and types using `typeof model.static`
- **Mandate**:
  - **Controller**: Use Elysia instance as controller (1 instance = 1 controller)
  - **Service**: Use pure functions (no HTTP dependencies, no classes)
  - **Model**: Define TypeBox schemas in `model.ts`, use `Static<typeof schema>` for types
- **Type Exports**: âŒ **FORBIDDEN** `export namespace`, âœ… **REQUIRED** direct type exports: `export type TypeName = Static<typeof schema>`
  - **Schema Derivation**: Derive from `@juchang/db` schemas, avoid manual re-typing
  - **OpenAPI**: Swagger plugin outputs JSON at `/doc/json` (no UI).
  - **Strict Responses**: Response types MUST match the TypeBox schema in route definition.

## 4. apps/miniprogram (The Client)
- **Tech**: Native Wechat (Skyline/WebView) + Vite + TS.
- **Mandate**:
  - **NO Manual Requests**: DO NOT use `wx.request` for business logic.
  - **Use SDK**: Import methods from `@/api/generated.ts` (Generated by Orval).
  - **Styling**: Use SCSS.

## 5. apps/web (The Console)
- **Tech**: Next.js 16 + Server Actions + Eden Treaty.
- **Mandate**:
  - **Eden Treaty**: Use `import { api } from '@/lib/eden'` for type-safe API calls.
  - **Direct Service Calls**: Can also call `@juchang/services` directly in Server Actions (Zero-API overhead).
  - **Type Safety**: Eden Treaty provides full type inference from Elysia API.

---

# ğŸš« The "NO MANUAL TYPEBOX" Rule (CRITICAL)

**When defining API Inputs/Outputs:**
1.  **FORBIDDEN**: Creating a root-level `t.Object({ ... })` that mirrors a DB table.
    - *Wrong*: `const UserResponse = t.Object({ id: t.String(), nickname: t.String() });`
2.  **REQUIRED**: Derive from `@juchang/db` schemas.
    - *Right (Select)*: `import { selectUserSchema } from '@juchang/db';`
    - *Right (Partial)*: `t.Pick(selectUserSchema, ['id', 'nickname'])` or manually construct with `t.Object({ id: t.String(), nickname: t.String() })`
    - *Right (Computed)*: `t.Extend(selectUserSchema, { distance: t.Number() })` or manually construct
    - *Right (List)*: `t.Array(selectUserSchema);`

**Exception**: purely transient parameters (e.g., `lat/lng` query params, `page`, `limit`) can be manually defined.

---

# ğŸ“œ Spec-Coding Workflow

When implementing a feature (e.g., "Find Nearby Activities"):

1.  **DB Check**: Define/Update table in `@juchang/db`. Ensure `geometry` column exists. Export TypeBox schemas.
2.  **Service Logic**: Implement `findNearbyActivities({ lat, lng })` function in `@juchang/services` using PostGIS functions.
3.  **Contract Definition**:
    - In `apps/api`, define route using Elysia: `.get('/activities/nearby', handler, { query: ..., response: ... })`.
    - **Request**: `t.Object({ lat: t.Number(), lng: t.Number() })`.
    - **Response**: `t.Array(selectActivitySchema)` or derived schema.
4.  **Route Implementation**:
    - Call service function -> Return data (Elysia auto-serializes).
5.  **SDK Gen**: Run `bun run gen:api` to update `apps/miniprogram/src/api/generated.ts`.

---

# ğŸ“ Coding Standards

- **Naming**:
  - Database: `snake_case` (e.g., `user_id`, `created_at`).
  - TypeScript/JSON: `camelCase` (e.g., `userId`, `createdAt`).
  - *Note*: Drizzle handles the mapping automatically.
- **Error Handling**:
  - Use Elysia's error handling or throw standard Error.
  - Standard Format: `{ code: number, msg: string, data?: any }`.
- **Package Manager**:
  - Use **Bun** for all operations: `bun install`, `bun run dev`, etc.
  - Lockfile: `bun.lockb` (binary, should be committed).

---

# ğŸ”§ Elysia Best Practice Example

## Folder Structure
```
apps/api/src/modules/
  users/
    user.controller.ts  # Controller (Elysia instance)
    user.service.ts     # Service (business logic)
    user.model.ts       # Model (TypeBox schemas)
```

## Model Example (model.ts)
```typescript
// Model - TypeBox schemas and types
import { Elysia, t, type Static } from 'elysia';
import { selectUserSchema } from '@juchang/db';

/**
 * Model Plugin
 * éµå¾ª Single Source of Truth åŸåˆ™ï¼š
 * - ä» DB schema æ´¾ç”Ÿå­—æ®µå®šä¹‰ï¼ˆä½¿ç”¨ t.Pick, t.Omit, t.Intersectï¼‰
 * - ç¬æ€å‚æ•°ï¼ˆå¦‚ passwordã€pageã€limitï¼‰å¯æ‰‹åŠ¨å®šä¹‰
 * - ä½¿ç”¨ Static<typeof schema> è‡ªåŠ¨æ¨å¯¼ç±»å‹
 */

// è·¯å¾„å‚æ•°ï¼ˆç¬æ€å‚æ•°ï¼Œæ‰‹åŠ¨å®šä¹‰ï¼‰
const IdParams = t.Object({
  id: t.String({ format: 'uuid' }),
});

// ç™»å½•è¯·æ±‚ï¼ˆä» DB schema æ´¾ç”Ÿ phoneNumberï¼Œæ‰‹åŠ¨å®šä¹‰ passwordï¼‰
const LoginRequest = t.Intersect([
  t.Pick(selectUserSchema, ['phoneNumber']),
  t.Object({
    password: t.String({ minLength: 8 }),
  }),
]);

// é”™è¯¯å“åº”ï¼ˆç¬æ€å‚æ•°ï¼Œæ‰‹åŠ¨å®šä¹‰ï¼‰
const ErrorResponse = t.Object({
  code: t.Number(),
  msg: t.String(),
});

// æ³¨å†Œåˆ° Elysia Model Plugin
export const userModel = new Elysia({ name: 'userModel' })
  .model({
    'user.idParams': IdParams,
    'user.login': LoginRequest,
    'user.error': ErrorResponse,
  });

// å¯¼å‡º TS ç±»å‹ï¼ˆä½¿ç”¨ Static<typeof schema> è‡ªåŠ¨æ¨å¯¼ï¼‰
// âŒ ç¦æ­¢ä½¿ç”¨ export namespaceï¼Œæ”¹ä¸ºç›´æ¥å¯¼å‡ºç±»å‹
export type IdParams = Static<typeof IdParams>;
export type LoginRequest = Static<typeof LoginRequest>;
export type ErrorResponse = Static<typeof ErrorResponse>;
```

## Service Example (service.ts)
```typescript
// Service - Pure function, no HTTP dependencies
import { db, users, eq } from '@juchang/db';
import type { ErrorResponse } from './user.model';

export async function getUserById(id: string) {
  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.id, id))
    .limit(1);
  
  return user || null;
}
```

## Controller Example (controller.ts)
```typescript
// Controller - Elysia instance as controller
import { Elysia } from 'elysia';
import { selectUserSchema } from '@juchang/db';
import { userModel, type ErrorResponse } from './user.model';
import { getUserById } from './user.service';

export const userController = new Elysia({ prefix: '/users' })
  .use(userModel) // å¼•å…¥ Model Plugin
  .get(
    '/:id',
    async ({ params, set }) => {
      const user = await getUserById(params.id);
      
      if (!user) {
        set.status = 404;
        return {
          code: 404,
          msg: 'ç”¨æˆ·ä¸å­˜åœ¨',
        } satisfies ErrorResponse;
      }
      
      return user;
    },
    {
      detail: {
        tags: ['Users'],
        summary: 'è·å–ç”¨æˆ·è¯¦æƒ…',
      },
      params: 'user.idParams', // å¼•ç”¨ Model Plugin ä¸­æ³¨å†Œçš„ schema
      response: {
        200: selectUserSchema, // ç›´æ¥ä½¿ç”¨ DB schema
        404: 'user.error',     // å¼•ç”¨ Model Plugin ä¸­æ³¨å†Œçš„ schema
      },
    }
  );
```

## Schema Derivation Patterns

### 1. ç›´æ¥ä½¿ç”¨ DB Schema
```typescript
// âœ… æ­£ç¡®ï¼šç›´æ¥ä½¿ç”¨
response: {
  200: selectUserSchema,
}
```

### 2. é€‰æ‹©éƒ¨åˆ†å­—æ®µï¼ˆPickï¼‰
```typescript
// âœ… æ­£ç¡®ï¼šä» DB schema é€‰æ‹©å­—æ®µ
const UserSummary = t.Pick(selectUserSchema, ['id', 'nickname', 'avatarUrl']);
```

### 3. æ’é™¤å­—æ®µï¼ˆOmitï¼‰
```typescript
// âœ… æ­£ç¡®ï¼šæ’é™¤æ•æ„Ÿå­—æ®µ
const PublicUser = t.Omit(selectUserSchema, ['phoneNumber', 'wxOpenId']);
```

### 4. æ‰©å±•å­—æ®µï¼ˆIntersectï¼‰
```typescript
// âœ… æ­£ç¡®ï¼šç»„åˆ DB schema å’Œè‡ªå®šä¹‰å­—æ®µ
const UserWithDistance = t.Intersect([
  selectUserSchema,
  t.Object({
    distance: t.Number(), // è®¡ç®—å­—æ®µ
  }),
]);
```

### 5. ç»„åˆå¤šä¸ª Schema
```typescript
// âœ… æ­£ç¡®ï¼šç»„åˆå¤šä¸ªæ´¾ç”Ÿ schema
const LoginRequest = t.Intersect([
  t.Pick(selectUserSchema, ['phoneNumber']), // ä» DB æ´¾ç”Ÿ
  t.Object({
    password: t.String(), // ç¬æ€å‚æ•°
  }),
]);
```

### 6. æ•°ç»„å“åº”
```typescript
// âœ… æ­£ç¡®ï¼šæ•°ç»„å“åº”
const UserListResponse = t.Object({
  data: t.Array(selectUserSchema),
  total: t.Number(),
});
```

## Model Plugin ä½¿ç”¨è§„èŒƒ

### æ³¨å†Œ Schema
```typescript
// model.ts
export const userModel = new Elysia({ name: 'userModel' })
  .model({
    'user.idParams': IdParams,        // ä½¿ç”¨å‘½åç©ºé—´å‰ç¼€é¿å…å†²çª
    'user.login': LoginRequest,
    'user.error': ErrorResponse,
  });
```

### åœ¨ Controller ä¸­å¼•ç”¨
```typescript
// controller.ts
export const userController = new Elysia({ prefix: '/users' })
  .use(userModel) // å¿…é¡»å…ˆ use Model Plugin
  .get(
    '/:id',
    handler,
    {
      params: 'user.idParams',  // ä½¿ç”¨å­—ç¬¦ä¸²å¼•ç”¨æ³¨å†Œçš„ schema
      response: {
        200: selectUserSchema,  // å¯ä»¥ç›´æ¥ä½¿ç”¨ DB schema
        404: 'user.error',      // æˆ–ä½¿ç”¨å­—ç¬¦ä¸²å¼•ç”¨æ³¨å†Œçš„ schema
      },
    }
  );
```

### ç±»å‹å¯¼å‡ºè§„èŒƒ
```typescript
// âŒ é”™è¯¯ï¼šä½¿ç”¨ namespace
export namespace UserModel {
  export type idParams = Static<typeof IdParams>;
}

// âœ… æ­£ç¡®ï¼šç›´æ¥å¯¼å‡ºç±»å‹
export type IdParams = Static<typeof IdParams>;
export type ErrorResponse = Static<typeof ErrorResponse>;
```

### åœ¨ Service ä¸­ä½¿ç”¨ç±»å‹
```typescript
// service.ts
import type { ErrorResponse, IdParams } from './user.model';

// ç±»å‹å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€é€šè¿‡ namespace
function handleError(): ErrorResponse {
  return { code: 404, msg: 'Not found' };
}
```

---

# ğŸ¤– Instruction for AI Generation

When I ask for a feature:
1.  **Plan**: Analyze `@juchang/db` first. Do we need new columns?
2.  **Schema**: Show me the `drizzle-typebox` derivation strategy (e.g., "I'll use `t.Pick(selectUserSchema, ['id', 'nickname'])`" or "I'll manually construct with `t.Object()`").
3.  **Service**: Write pure function (not class): `export async function getUserById(id: string) { ... }`
4.  **API**: Write the Elysia route with TypeBox schemas.
5.  **Frontend**: If asked for UI, show how to call the **Eden Treaty** (Web) or **Orval SDK** (MiniProgram), not raw fetch.

---

# âš ï¸ Important Notes

- **TypeBox vs Zod**: We use TypeBox (t) from Elysia, NOT Zod (z). TypeBox is 50x faster.
- **Elysia vs Hono**: We use ElysiaJS, NOT Hono. Elysia is optimized for Bun.
- **Bun Runtime**: All scripts use `bun run`, not `npm` or `pnpm`.
- **Function-Based Services**: Services are pure functions, not classes.
- **Eden Treaty**: Web clients use Eden Treaty for type-safe API calls (zero code generation).
- **Orval SDK**: MiniProgram uses Orval-generated SDK (because Proxy is not supported).
