这份 **《聚场 (Juchang) - 现代化全栈架构方案》** 是基于我们多轮深度讨论的最终定稿。

采用了 **“原生小程序 + Next.js Web + Hono API + Drizzle ORM”** 的现代化全栈架构，同时利用 **Monorepo** 和 **Internal Packages** 实现了后端与前端、Web 与小程序之间的逻辑复用。

---

# 聚场 (Juchang) - 总体技术架构方案 (v4.0 Final)

## 1. 核心设计理念

1.  **原生极致性能**：小程序端完全放弃 React/Vue 运行时，编写原生 `WXML/WXSS/TS`，确保启动速度和运行性能达到“天花板”级别。
2.  **现代化全栈体验**：Web端采用 **Next.js 15** (App Router) 提供卓越的SSR/SSG体验，API层使用 **Hono** 提供高性能的Edge运行时支持。
3.  **逻辑高度复用**：采用 **Monorepo (Internal Packages)** 策略，核心业务逻辑（用户管理、LBS算法、支付、AI）封装为纯 TS 源码包，API端、Web端和小程序端**直接引用源码**，无中间编译产物。
4.  **类型安全优先**：从数据库到API到前端，全链路TypeScript，结合 **Drizzle ORM** 和 **Zod** 实现端到端的类型安全。
5.  **未来不过时**：基于 Web 标准（Hono, PostGIS, Drizzle），不依赖特定厂商的黑盒框架，架构生命周期长。

---

## 2. 技术栈全景图 (Tech Stack)

| 模块           | 选型                     | 核心理由                                                                     |
| :------------- | :----------------------- | :--------------------------------------------------------------------------- |
| **代码管理**   | **Turborepo + pnpm**     | 任务编排与依赖管理，支持源码引用的 Workspace 模式。                          |
| **小程序构建** | **weapp-vite (Native)**  | **核心变革点**。使用 Vite 编译原生小程序，支持 TS、SCSS，零运行时开销。 |
| **Web应用**    | **Next.js 15 (App Router)** | 现代化的全栈React框架，提供卓越的SSR/SSG体验，支持React 19新特性。 |
| **API网关**    | **Hono**                 | 符合 Web Standards 的高性能后端，支持 Node/Edge，类型推断极致。              |
| **数据库**     | **PostgreSQL + PostGIS** | 处理 LBS 社交（附近的人、地理围栏、距离计算）的行业标准。                    |
| **ORM**        | **Drizzle ORM**          | TypeScript Native，无运行时开销，生成高效 SQL，完美支持Zod模式验证。        |
| **模式验证**   | **Zod**                  | TypeScript优先的模式验证库，与Drizzle完美集成，实现端到端类型安全。        |
| **基础设施**   | **Redis + Docker**       | 缓存与容器化部署。                                                           |
| **AI/风控**    | **LLM API + 腾讯云 IMS** | 通过 Hono 流式输出 AI 响应；强制接入第三方内容安全服务。                     |

---

## 3. 系统逻辑架构图

```mermaid
graph TD
    subgraph "Client Side (前端应用)"
        MP[微信小程序 (Native + Vite)]
        Web[Web应用 (Next.js 15 App Router)]
        Admin[管理后台 (Next.js 15)]
    end

    subgraph "Server Side (服务端)"
        API[Hono API Gateway]
        Next[Next.js API Routes]
    end

    subgraph "Shared Logic Layer (纯 TS 源码包)"
        Services[Services层 (用户/LBS/AI)]
        DB[Database层 (Drizzle + Zod)]
        Utils[通用工具 (Format/Validator)]
    end

    subgraph "Data Layer (基础设施)"
        PostgreSQL[(PostgreSQL + PostGIS)]
        Redis[(Redis Cache)]
        LLM[大模型 API]
        RiskAPI[腾讯云内容安全]
    end

    %% 编译时依赖 (Build Time)
    MP -.->|Vite 编译引入| Services & Utils
    Web -.->|Next.js 编译引入| Services & Utils
    Admin -.->|Next.js 编译引入| Services & Utils

    %% 运行时依赖 (Runtime)
    API -->|Import| Services
    Next -->|Import| Services
    Services -->|Drizzle ORM| DB
    DB -->|SQL| PostgreSQL
    
    MP -->|HTTPS / WSS| API
    Web -->|HTTPS| Next
    Admin -->|HTTPS| API

    %% 数据流向
    Services -->|Cache| Redis
    API -->|SSE Stream| MP
    Services -->|Content Check| RiskAPI
    Services -->|AI Stream| LLM
```

---

## 4. 目录结构设计 (Internal Packages 模式)

所有 `packages/*` 均配置为 **No-Build** 模式（`main` 指向 `.ts`），由上层应用（Apps）的 Vite/Next.js 负责编译。

```text
/root
  ├── apps/
  │    ├── miniprogram/     # [Native] 原生小程序
  │    │    ├── src/
  │    │    │    ├── app.json
  │    │    │    ├── pages/index/index.ts  # 直接 import @juchang/services
  │    │    │    └── pages/index/index.wxml
  │    │    ├── vite.config.ts  # 配置 weapp-vite & alias
  │    │    └── tsconfig.json
  │    │
  │    ├── web/             # [Next.js 15] 主Web应用
  │    │    ├── app/         # App Router
  │    │    │    ├── page.tsx
  │    │    │    └── api/    # API Routes
  │    │    └── next.config.ts
  │    │
  │    └── api/             # [Hono] API 网关
  │         └── src/index.ts
  │
  ├── packages/
  │    ├── db/              # 数据库层 (Drizzle ORM + Zod)
  │    │    ├── src/
  │    │    │    ├── db.ts       # 数据库客户端初始化
  │    │    │    ├── index.ts    # 统一导出入口
  │    │    │    ├── migrate.ts  # 迁移脚本
  │    │    │    └── schema/     # Drizzle 表定义
  │    │    │         ├── index.ts        # Schema 统一导出
  │    │    │         ├── enums.ts        # 枚举类型定义
  │    │    │         ├── users.ts        # 用户表
  │    │    │         ├── activities.ts   # 活动表
  │    │    │         ├── participants.ts # 参与者表
  │    │    │         ├── orders.ts       # 订单表
  │    │    │         ├── products.ts     # 商品表
  │    │    │         ├── payments.ts     # 支付表
  │    │    │         ├── user_assets.ts  # 用户资产表
  │    │    │         └── asset_records.ts # 资产记录表
  │    │    ├── drizzle.config.ts
  │    │    ├── package.json
  │    │    └── tsconfig.json
  │    │
  │    ├── services/        # [核心] 业务逻辑 (CRUD + 算法)
  │    │    ├── src/
  │    │    │    ├── users/      # 用户管理CRUD
  │    │    │    ├── lbs.ts      # 地理算法
  │    │    │    ├── economy.ts  # 虚拟币逻辑
  │    │    │    └── ai.ts       # Prompt 模版
  │    │    └── package.json    # "main": "./src/index.ts"
  │    │
  │    ├── utils/           # 通用工具 (时间格式化, 价格处理)
  │    └── ts-config/       # 统一 TS 配置
  │
  ├── docker/              # Docker配置
  │    ├── docker-compose.yml
  │    ├── .env.example
  │    └── redis.conf
  │
  ├── turbo.json
  ├── pnpm-workspace.yaml
  └── .env.example         # 根目录环境变量
```

---

## 5. 关键业务模块实现方案

### 5.1 数据流架构 (Drizzle -> Zod -> Next/Hono)

**基础用户数据流示例：**

```typescript
// 1. Database Schema (packages/db/src/schema/users.ts)
export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  wxOpenId: varchar('wx_openid', { length: 128 }).notNull().unique(),
  nickname: varchar('nickname', { length: 50 }),
  location: geometry('location', { type: 'point', srid: 4326 }),
  creditScore: integer('credit_score').default(100),
  createdAt: timestamp('created_at').defaultNow(),
});

// 2. Zod Schema for validation (packages/services/users/validation.ts)
export const userSchema = z.object({
  wxOpenId: z.string().min(1).max(128),
  nickname: z.string().min(1).max(50).optional(),
  location: z.object({ lat: z.number(), lng: z.number() }).optional(),
});

// 3. Service Layer (packages/services/users/service.ts)
export class UserService {
  async createUser(data: z.infer<typeof userSchema>) {
    const validated = userSchema.parse(data);
    return await db.insert(users).values({
      wxOpenId: validated.wxOpenId,
      nickname: validated.nickname,
      location: validated.location ? `POINT(${validated.location.lng} ${validated.location.lat})` : null,
    }).returning();
  }
}

// 4. API Layer (apps/api/src/routes/users.ts or apps/web/app/api/users/route.ts)
app.post('/api/users', async (c) => {
  const data = await c.req.json();
  const userService = new UserService();
  const user = await userService.createUser(data);
  return c.json(user);
});
```

**资产体系数据流示例（双账本设计）：**

```typescript
// 1. Database Schema (packages/db/src/schema/user_assets.ts & asset_records.ts)
export const userAssets = pgTable('user_assets', {
  userId: uuid('user_id').notNull().references(() => users.id),
  assetId: assetIdEnum('asset_id').notNull(), // 'coin', 'point', 'speed_match_card' 等
  category: assetCategoryEnum('category').notNull(), // 'currency', 'consumable', 'badge'
  balance: integer('balance').notNull().default(0),
  metadata: jsonb('metadata'),
}, (t) => [
  primaryKey({ columns: [t.userId, t.assetId] }),
]);

export const assetRecords = pgTable('asset_records', {
  id: bigint('id', { mode: 'number' }).primaryKey().generatedAlwaysAsIdentity(),
  userId: uuid('user_id').notNull().references(() => users.id),
  assetId: assetIdEnum('asset_id').notNull(),
  amount: integer('amount').notNull(), // 正数为获取，负数为消耗
  balanceSnapshot: integer('balance_snapshot').notNull(), // 变动后的余额快照
  reason: assetChangeReasonEnum('reason').notNull(), // 'recharge', 'payment_use', 'check_in' 等
  relatedOrderId: uuid('related_order_id').references(() => orders.id),
  description: text('description'),
  createdAt: timestamp('created_at').defaultNow(),
});

// 2. Zod Schema for validation (packages/services/economy/validation.ts)
export const rechargeSchema = z.object({
  productId: z.string().uuid(),
  paymentMethod: z.enum(['wechat', 'asset']),
});

// 3. Service Layer (packages/services/economy/service.ts)
export class EconomyService {
  async recharge(userId: string, data: z.infer<typeof rechargeSchema>) {
    const validated = rechargeSchema.parse(data);
    
    // 事务处理：创建订单 -> 支付 -> 增加资产 -> 记录流水
    return await db.transaction(async (tx) => {
      // 1. 查询商品信息
      const product = await tx.select().from(products).where(eq(products.id, validated.productId));
      if (!product[0]) throw new Error('Product not found');
      
      // 2. 创建订单
      const order = await tx.insert(orders).values({
        userId,
        productId: validated.productId,
        paymentMethod: validated.paymentMethod,
        status: 'pending',
      }).returning();
      
      // 3. 处理支付（微信支付或资产支付）
      if (validated.paymentMethod === 'wechat') {
        // 创建支付记录，等待回调
        await tx.insert(payments).values({
          orderId: order[0].id,
          userId,
          amount: product[0].priceCny || 0,
          status: 'pending',
        });
      } else {
        // 资产支付：扣除资产余额
        await this.deductAsset(tx, userId, product[0].priceAssetId!, product[0].priceAssetAmount!);
      }
      
      // 4. 支付成功后，根据商品配置增加资产
      const config = product[0].config as { assets: Array<{ id: string; amount: number }> };
      
      for (const asset of config.assets) {
        await this.addAsset(tx, userId, asset.id, asset.amount, 'recharge', order[0].id);
      }
      
      return order[0];
    });
  }
  
  private async addAsset(tx: any, userId: string, assetId: string, amount: number, reason: string, orderId?: string) {
    // 更新或插入余额
    await tx.insert(userAssets).values({
      userId,
      assetId,
      category: this.getCategory(assetId),
      balance: amount,
    }).onConflictDoUpdate({
      target: [userAssets.userId, userAssets.assetId],
      set: { balance: sql`${userAssets.balance} + ${amount}` },
    });
    
    // 获取最新余额作为快照
    const latest = await tx.select().from(userAssets)
      .where(and(eq(userAssets.userId, userId), eq(userAssets.assetId, assetId)));
    const balanceSnapshot = latest[0]?.balance || amount;
    
    // 插入流水记录
    await tx.insert(assetRecords).values({
      userId,
      assetId,
      amount,
      balanceSnapshot,
      reason,
      relatedOrderId: orderId,
    });
  }
}

// 4. API Layer (apps/api/src/routes/economy.ts)
app.post('/api/economy/recharge', async (c) => {
  const userId = c.get('userId'); // 从认证中间件获取
  const data = await c.req.json();
  const economyService = new EconomyService();
  const order = await economyService.recharge(userId, data);
  return c.json(order);
});
```

### 5.2 原生小程序工程化 (Native + Vite)

- **痛点解决**：原生小程序缺乏 npm 支持、缺乏 TS 支持、构建慢。
- **解决方案**：
  - **构建**：`vite.config.ts` 中引入 `weapp-vite` 插件。
  - **源码引用**：配置 `resolve.alias` 将 `@juchang/services` 指向 `../../packages/services/src/index.ts`。
  - **效果**：Vite 自动将 TS 编译为 JS，将 npm 包打包进 `miniprogram_npm` (或内联)，并处理 Tree-shaking。
  - **热更新**：修改 `packages` 里的代码，小程序模拟器秒级刷新。

### 5.3 Next.js Web应用 (App Router)

- **服务端渲染**：利用Next.js 15的App Router实现优秀的SEO和首屏性能
- **API Routes**：内置API路由，可直接调用services层
- **全栈类型安全**：从数据库到前端，完整的TypeScript支持
- **部署优化**：支持Edge Runtime，与Hono API共享运行时环境

### 5.4 LBS 社交与“她模式” (PostGIS)

- **存储**：`packages/db` 定义 geometry 字段。
- **逻辑 (`packages/services/lbs.ts`)**：
  - **附近查询**：封装 `ST_DWithin` SQL 查询。
  - **她模式 (She-Mode)**：
    - 前端：小程序开关触发，传入 `sheMode=true` 参数。
    - 后端（Shared Service）：
      ```typescript
      if (params.sheMode) {
        sql.where(
          and(
            eq(activity.riskLevel, 'low'), // 过滤高风险
            gte(activity.femaleParticipants, 3) // 仅显示女性友好
          )
        );
      }
      ```

### 5.5 资产体系与双账本设计

- **设计原则**：多资产类型 + 双账本审计（余额账本 + 流水账本）。
- **核心表结构**：
  - `user_assets` - **余额账本**：存储用户当前资产余额（支持多种资产：金币、积分、道具卡等）
  - `asset_records` - **流水账本**：记录所有资产变动历史（带余额快照，用于财务审计）
  - `orders` - **业务订单**：统一订单入口，支持法币支付和资产支付
  - `payments` - **支付流水**：专门处理外部支付网关（微信支付、支付宝等）
  - `products` - **商品定义**：支持法币定价和资产定价，定义交付内容

- **资产类型体系**：
  - **货币类**：`coin` (金币)、`point` (积分)
  - **道具类**：`speed_match_card` (加速匹配卡)、`super_like` (超级喜欢)、`activity_top_card` (活动置顶卡) 等
  - **权益类**：`early_bird_badge` (早鸟徽章)、`verified_badge` (认证标识) 等

- **业务流程 (`packages/services/economy.ts`)**：
  - **充值流程**：
    1. 用户选择商品（如"100金币包"）-> 创建 `orders` 订单
    2. 发起微信支付 -> 创建 `payments` 支付记录
    3. 支付回调成功 -> 更新 `payments.status = 'success'`
    4. 事务处理：
       - 更新 `orders.status = 'paid'`
       - 根据 `products.config` 增加 `user_assets` 对应资产余额
       - 插入 `asset_records` 流水记录（带余额快照）
  
  - **资产支付流程**（如用金币买AI服务）：
    1. 用户选择商品 -> 创建 `orders` 订单（`paymentMethod = 'asset'`）
    2. 事务处理：
       - 扣除 `user_assets` 对应资产余额（如 `coin`）
       - 插入 `asset_records` 消耗流水
       - 更新 `orders.status = 'paid'`
    3. 根据商品类型执行交付逻辑（如放行AI请求、发放道具等）
  
  - **资产变动审计**：
    - 每次变动都记录 `asset_records.balanceSnapshot`（变动后的余额）
    - 财务对账时可通过快照验证余额一致性，防止数据篡改
    - 支持按 `reason`（变动原因）分类查询：充值、签到、消费、退款等

- **实现位置**：此逻辑在 **Hono API** 中调用，所有资产操作使用数据库事务确保原子性。

### 5.6 AI 流式对话 (Streamed SSE)

- **场景**：AI 助手页、活动策划。
- **实现**：
  - 小程序：使用 `wx.request` 的 `enableChunked: true` 接收流。
  - Next.js/Hono API：使用 `streamText` 返回 SSE (Server-Sent Events)。
  - Prompt：在 `packages/services/ai.ts` 中预设 Prompt 模板，不暴露给前端。

---

## 6. 数据与安全架构

### 6.1 数据库 Schema (Drizzle + Zod)

数据库层采用模块化设计，所有表定义位于 `packages/db/src/schema/` 目录下：

**Schema 文件结构：**
- `enums.ts` - 枚举类型定义（用户性别、会员类型、订单状态、支付方式等）
- `users.ts` - 用户表（认证、资料、资产、会员、信用等）
- `activities.ts` - 活动表（LBS 地理位置、参与者规则、风控等）
- `participants.ts` - 参与者表（活动报名关系）
- `orders.ts` - 订单表（商品快照、支付信息、状态流转）
- `products.ts` - 商品表（金币包、会员卡、AI服务、虚拟礼物等）
- `payments.ts` - 支付表（微信支付流水、回调记录）
- `user_assets.ts` - 用户资产表（金币余额、会员状态等）
- `asset_records.ts` - 资产记录表（金币变动流水、余额快照）

**示例代码：**

```typescript
// packages/db/src/schema/activities.ts
export const activities = pgTable('activities', {
  id: uuid('id').primaryKey().defaultRandom(),
  title: varchar('title', { length: 100 }).notNull(),
  location: geometry('location', { type: 'point', srid: 4326 }).notNull(), // PostGIS
  isFemaleFriendly: boolean('is_female_friendly').default(false),
  status: varchar('status', { length: 20 }).default('active'), // active, cancelled, completed
  riskLevel: varchar('risk_level', { length: 10 }).default('low'),
  hostId: uuid('host_id').notNull().references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
});

// packages/db/src/db.ts - 数据库客户端初始化
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

export const db = drizzle(client, { schema });

// Zod validation schema (位于 packages/services 层)
export const activitySchema = z.object({
  title: z.string().min(1).max(100),
  location: z.object({ lat: z.number(), lng: z.number() }),
  type: z.enum(['food', 'sports', 'culture', 'entertainment', 'travel', 'study']),
  maxParticipants: z.number().min(2).max(20),
});
```

### 6.2 内容安全风控 (红线)

- **拦截机制**：在 `packages/services` 层封装 `checkContent(text, image)`。
- **强制执行**：
  - 创建活动 API
  - 修改资料 API
  - 发布评论 API
  - **必须**先 `await checkContent()`，通过后才能写入数据库。

---

## 7. 开发与构建流程

### 7.1 开发环境 (Dev)

**命令**：`pnpm dev` (根目录)

1.  **Turbo** 并行启动任务。
2.  **Hono API**: `tsx watch` 启动，直接运行 TS。
3.  **Next.js Web**: `next dev` 启动，支持App Router和API Routes。
4.  **Miniprogram**: `weapp-vite` 启动，监听文件变化 -> 编译原生代码 -> 输出到 `dist/`。
5.  **开发者工具**：开发者只需打开 `apps/miniprogram/dist`，即可看到实时效果。

### 7.2 生产部署 (Build)

**命令**：`pnpm build`

1.  **Next.js**: 构建优化后的生产包，支持Edge Runtime。
2.  **Hono API**: 构建 Docker 镜像，部署到服务器或Edge平台。
3.  **Miniprogram**: `weapp-vite` 执行生产构建（压缩、去无用代码），生成优化后的 `dist` 包 -> 上传微信后台。

---

## 8. 环境变量管理

### 8.1 根目录环境变量 (.env.example)

```bash
# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/juchang

# Redis
REDIS_URL=redis://localhost:6379

# API
API_PORT=3000
NEXT_PUBLIC_API_URL=http://localhost:3000

# WeChat
WECHAT_APP_ID=your_wechat_app_id
WECHAT_APP_SECRET=your_wechat_app_secret

# AI
AI_API_KEY=your_ai_api_key
```

### 8.2 Docker环境变量 (docker/.env.example)

```bash
# PostgreSQL
POSTGRES_DB=juchang
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_secure_password_here
POSTGRES_PORT=5432

# Redis
REDIS_PORT=6379
```

---

## 9. 总结

这套架构方案完美契合了**“现代化全栈开发”**的需求：

1.  **Next.js 15**: 提供卓越的Web体验和全栈开发能力
2.  **Drizzle ORM + Zod**: 实现从数据库到API的完整类型安全
3.  **原生小程序**: 保持极致的移动端性能
4.  **Turborepo + Internal Packages**: 实现真正的全栈逻辑复用
5.  **Hono + PostGIS**: 服务端轻量且强大，完美支撑LBS业务

这是一个**现代化、高性能、类型安全、易于维护**的工业级全栈架构。
