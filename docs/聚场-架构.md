这份 **《聚场 (Juchang) - 现代化全栈架构方案》** 是基于我们多轮深度讨论的最终定稿。

采用了 **"原生小程序 + Next.js Admin + Hono API + Drizzle ORM"** 的现代化全栈架构，同时利用 **Monorepo** 和 **Internal Packages** 实现了后端与前端、Web 与小程序之间的逻辑复用。

---

# 聚场 (Juchang) - 总体技术架构方案 (v5.1 对齐 PRD V7.0)

## 1. 核心设计理念

1. **原生极致性能**：小程序端完全放弃 React/Vue 运行时，使用 **weapp-vite** 编译原生 `WXML/WXSS/TS`。**核心价值**：weapp-vite 不仅提供编译能力，更重要的是支持原生开发的高性能（零运行时开销、直接调用微信原生 API），确保启动速度和运行性能达到"天花板"级别。
2. **数据库优先 (Database First)**：`@repo/db` (Drizzle ORM) 是绝对的数据源。所有 Zod Schema 必须通过 `drizzle-zod` 自动生成，**禁止手动定义 Zod**（除非是纯瞬态参数）。
3. **Spec-Coding 契约驱动**：使用 `@hono/zod-openapi` 定义路由契约，集成 **Scalar** 提供美观的 API 文档，使用 **Orval** 自动生成客户端 SDK。
4. **双轨架构 (Dual-Track)**：
   - **API Server (Hono)**：服务微信小程序，认证使用 **JWT**。
   - **Admin Console (Next.js 15)**：服务管理员，认证使用 **Iron-Session/Cookie**，通过 Server Actions 直接调用 `@repo/services`（无 HTTP 开销）。
5. **逻辑高度复用**：采用 **Monorepo (Internal Packages)** 策略，核心业务逻辑（用户管理、LBS算法、支付、AI）封装为纯 TS 源码包，API端、Web端和小程序端**直接引用源码**，无中间编译产物。
6. **类型安全优先**：从数据库到API到前端，全链路TypeScript，结合 **Drizzle ORM** 和 **drizzle-zod** 实现端到端的类型安全。
7. **极简主义 (Geek/Minimalist)**：移除 NestJS 等重型框架，采用 Hono 的轻量级中间件模式，代码简洁、性能卓越。

---

## 2. 技术栈全景图 (Tech Stack)

| 模块           | 选型                           | 核心理由                                                                     |
| :------------- | :----------------------------- | :--------------------------------------------------------------------------- |
| **代码管理**   | **Turborepo + pnpm**           | 任务编排与依赖管理，支持源码引用的 Workspace 模式。                          |
| **代码质量**   | **Biome**                      | 极速的 Linter + Formatter，替代 ESLint + Prettier。                         |
| **小程序构建** | **weapp-vite (Native)**        | **核心变革点**。使用 Vite 编译原生小程序，支持 TS、SCSS，零运行时开销。 |
| **Web应用**    | **Next.js 15 (App Router)**    | 现代化的全栈React框架，提供卓越的SSR/SSG体验，支持React 19新特性。 |
| **API网关**    | **Hono**                       | 符合 Web Standards 的高性能后端，运行在 VPS Node.js（非 Edge），类型推断极致。 |
| **API文档**    | **Scalar**                     | 基于 OpenAPI 的现代化 API 文档界面，集成 `@scalar/hono-api-reference`。 |
| **客户端SDK**  | **Orval**                      | 从 OpenAPI Spec 自动生成 TypeScript 客户端 SDK，小程序直接使用生成的 SDK。 |
| **数据库**     | **PostgreSQL + PostGIS**       | 处理 LBS 社交（附近的人、地理围栏、距离计算）的行业标准。                    |
| **ORM**        | **Drizzle ORM**                | TypeScript Native，无运行时开销，生成高效 SQL。                             |
| **Schema生成** | **drizzle-zod**                | **核心**：从 Drizzle Schema 自动生成 Zod Schema，实现 Single Source of Truth。 |
| **模式验证**   | **Zod**                        | TypeScript优先的模式验证库，与Drizzle完美集成，实现端到端类型安全。        |
| **基础设施**   | **Redis + Docker**             | 缓存与容器化部署。                                                           |
| **AI/风控**    | **LLM API + 腾讯云 IMS**       | 通过 Hono 流式输出 AI 响应；强制接入第三方内容安全服务。                     |

---

## 3. 系统逻辑架构图

```mermaid
graph TD
    subgraph "Client Side (前端应用)"
        MP[微信小程序 (Native + Vite)<br/>Map-First + CUI-First]
        Admin[管理后台 (Next.js 15 + Server Actions)]
        CUI[CUI 渲染引擎<br/>Markdown → 结构化卡片]
    end

    subgraph "API Server (Hono)"
        API[Hono API Gateway<br/>JWT Auth<br/>OpenAPI + Scalar]
        SDK[Orval 生成 SDK]
        SSE[SSE 流式输出<br/>AI Chat Stream]
    end

    subgraph "Shared Logic Layer (纯 TS 源码包)"
        Services[Services层 (用户/LBS/AI/支付)]
        DB[Database层 (Drizzle + drizzle-zod)]
        Utils[通用工具 (Format/Validator)]
        LBS[LBS 聚合引擎<br/>PostGIS Cluster]
    end

    subgraph "Data Layer (基础设施)"
        PostgreSQL[(PostgreSQL + PostGIS<br/>ST_ClusterDBSCAN)]
        Redis[(Redis Cache)]
        LLM[大模型 API]
        RiskAPI[腾讯云内容安全]
    end

    %% 编译时依赖 (Build Time)
    MP -.->|Vite 编译引入| Services & Utils
    Admin -.->|Next.js 编译引入| Services & Utils
    SDK -.->|从 OpenAPI 生成| API
    CUI -.->|Markdown 解析| MP

    %% 运行时依赖 (Runtime)
    API -->|Import| Services
    Admin -->|Server Actions 直接调用| Services
    Services -->|Drizzle ORM| DB
    DB -->|SQL| PostgreSQL
    Services -->|PostGIS 聚合查询| LBS
    LBS -->|聚合结果| PostgreSQL
    
    MP -->|HTTPS / 使用 SDK| API
    Admin -->|Iron-Session| Admin

    %% 数据流向
    Services -->|Cache| Redis
    API -->|SSE Stream| SSE
    SSE -->|流式输出| MP
    MP -->|解析 Markdown| CUI
    Services -->|Content Check| RiskAPI
    Services -->|AI Stream| LLM

    %% Schema 生成流
    DB -.->|drizzle-zod| Services
    Services -.->|Zod Schema| API
```

**核心数据流：**
1. **Database First**：`@repo/db` 定义表结构 → `drizzle-zod` 生成 Zod Schema → `@repo/services` 使用生成的 Schema → `apps/api-server` 使用 Zod 定义 OpenAPI 路由。
2. **Admin 直接访问**：Next.js Admin 通过 Server Actions 直接调用 `@repo/services`，无需经过 HTTP API。

---

## 4. 目录结构设计 (Internal Packages 模式)

所有 `packages/*` 均配置为 **No-Build** 模式（`main` 指向 `.ts`），由上层应用（Apps）的 Vite/Next.js 负责编译。

```text
/root
  ├── apps/
  │    ├── miniprogram/             # [WeChat 原生] Vite+TS 工程
  │    │    ├── src/
  │    │    │    ├── pages/
  │    │    │    │    ├── home/     # 地图首页 (Map-First 核心)
  │    │    │    │    ├── ai/       # AI 助手 (CUI-First 核心)
  │    │    │    │    ├── message/  # 消息列表/聊天
  │    │    │    │    ├── me/       # 个人中心
  │    │    │    │    ├── activity/ # 活动详情/创建/评价
  │    │    │    │    ├── search/   # 独立搜索页
  │    │    │    │    └── webview/  # 仅协议/政策承载
  │    │    │    ├── components/
  │    │    │    │    └── cui-renderer/  # CUI 渲染引擎 (Markdown → 卡片)
  │    │    │    ├── lib/            # 使用 Orval 生成的 SDK
  │    │    │    └── utils/          # 直接 import @repo/services
  │    │    ├── vite.config.ts
  │    │    └── tsconfig.json
  │    │
  │    ├── admin-web/               # [Next.js 15] 管理后台
  │    │    ├── app/                # App Router
  │    │    │    ├── (auth)/       # 登录页
  │    │    │    ├── (dashboard)/  # 仪表盘（需要 Iron-Session）
  │    │    │    └── api/          # Server Actions（直接调用 @repo/services）
  │    │    ├── lib/                # 直接 import @repo/services
  │    │    ├── next.config.ts
  │    │    └── middleware.ts      # Iron-Session 中间件
  │    │
  │    └── api-server/              # [Hono] API Gateway（服务小程序）
  │         ├── src/
  │         │    ├── routes/       # 路由定义（使用 @hono/zod-openapi）
  │         │    │    ├── auth.ts
  │         │    │    ├── users.ts
  │         │    │    ├── activities.ts
  │         │    │    │    └── check-in.ts  # POST /activities/:id/check-in
  │         │    │    ├── products.ts
  │         │    │    ├── orders.ts
  │         │    │    ├── payments.ts
  │         │    │    ├── assets.ts
  │         │    │    └── ai.ts              # POST /ai/chat (SSE 流式)
  │         │    ├── middleware/   # JWT 认证、错误处理、日志
  │         │    │    ├── auth.ts
  │         │    │    ├── error.ts
  │         │    │    └── logger.ts
  │         │    ├── app.ts         # Hono 应用实例
  │         │    └── index.ts       # 入口文件
  │         ├── orval.config.ts     # Orval 配置（生成 SDK）
  │         ├── package.json
  │         └── tsconfig.json
  │
  ├── packages/
  │    ├── db/                      # Drizzle ORM + drizzle-zod
  │    │    ├── drizzle.config.ts
  │    │    ├── src/
  │    │    │    ├── db.ts          # 数据库客户端
  │    │    │    ├── migrate.ts     # 迁移脚本
  │    │    │    ├── index.ts       # 导出所有 Schema 和 Zod
  │    │    │    └── schema/
  │    │    │         ├── enums.ts
  │    │    │         ├── users.ts / user_auths.ts
  │    │    │         ├── activities.ts / participants.ts
  │    │    │         ├── products.ts / orders.ts / payments.ts
  │    │    │         ├── user_assets.ts / asset_records.ts
  │    │    │         └── ai_messages.ts / ai_conversations.ts
  │    │    └── package.json
  │    │
  │    ├── services/                # 领域服务层（纯 TS）
  │    │    ├── src/
  │    │    │    ├── auth/
  │    │    │    ├── users/
  │    │    │    ├── activities/
  │    │    │    ├── products/
  │    │    │    ├── orders/
  │    │    │    ├── payments/
  │    │    │    ├── assets/
  │    │    │    └── ai.ts / lbs.ts / utils.ts
  │    │    └── package.json
  │    │
  │    ├── utils/                   # 通用工具包 (格式化 / 加解密)
  │    └── ts-config/               # 统一 TypeScript 配置
  │
  ├── docker/                      # 基础设施（Postgres + Redis）
  │    ├── docker-compose.yml
  │    ├── postgres/               # 自定义镜像 + init SQL
  │    └── .env.example
  │
  ├── turbo.json                   # Turborepo pipeline
  ├── pnpm-workspace.yaml          # Workspace 边界
  └── .env.example                 # 根环境变量模板
```

---

## 5. API 应用层架构（Hono 版）

### 5.1 目录结构

```
apps/api-server/
├── src/
│   ├── routes/                      # [路由层] OpenAPI 路由定义
│   │   ├── auth.ts                  # POST /auth/login (微信登录)
│   │   ├── users.ts                 # GET /users/me, PATCH /users/me
│   │   ├── activities.ts            # POST /activities, GET /activities/nearby
│   │   ├── products.ts              # GET /products
│   │   ├── orders.ts                # POST /orders
│   │   ├── payments.ts              # POST /payments/callback/wechat
│   │   └── assets.ts                # GET /assets/balance, GET /assets/records
│   │
│   ├── middleware/                  # [中间件层]
│   │   ├── auth.ts                  # JWT 认证中间件
│   │   ├── error.ts                 # 全局错误处理
│   │   └── logger.ts                # 请求日志
│   │
│   ├── app.ts                       # Hono 应用实例（注册路由、中间件）
│   └── index.ts                     # 入口文件（启动服务器）
│
├── orval.config.ts                  # Orval 配置（从 OpenAPI 生成 SDK）
├── package.json
└── tsconfig.json
```

### 5.2 核心工作流：Spec-Coding

**"Spec-Coding"** 是指先定义 OpenAPI 契约，再实现业务逻辑的开发模式。

#### 步骤 1：定义路由契约（使用 `@hono/zod-openapi`）

```typescript
// apps/api-server/src/routes/users.ts
import { createRoute, z } from '@hono/zod-openapi';
import { selectUserSchema } from '@repo/db'; // 从 DB 自动生成的 Zod Schema

// 定义路由契约
const getUserRoute = createRoute({
  method: 'get',
  path: '/users/me',
  summary: '获取当前用户信息',
  security: [{ Bearer: [] }], // 需要 JWT
  responses: {
    200: {
      description: '用户信息',
      content: {
        'application/json': {
          schema: selectUserSchema.omit({ password: true }), // 从 DB Schema 派生，隐藏密码
        },
      },
    },
  },
});

// 实现路由处理器
export const getUserHandler = async (c) => {
  const userId = c.get('userId'); // 从 JWT 中间件获取
  const userService = new UserService();
  const user = await userService.getById(userId);
  return c.json(user);
};
```

#### 步骤 2：注册路由到 Hono App

```typescript
// apps/api-server/src/app.ts
import { OpenAPIHono } from '@hono/zod-openapi';
import { apiReference } from '@scalar/hono-api-reference';
import { getUserRoute, getUserHandler } from './routes/users';

const app = new OpenAPIHono();

// 注册路由
app.openapi(getUserRoute, getUserHandler);

// 集成 Scalar 文档
app.get('/reference', apiReference({
  theme: 'purple',
  spec: {
    url: '/doc', // OpenAPI JSON 端点
  },
}));

// 导出 OpenAPI JSON
app.doc('/doc', {
  openapi: '3.0.0',
  info: {
    title: '聚场 API',
    version: '1.0.0',
  },
});

export default app;
```

#### 步骤 3：使用 Orval 生成客户端 SDK

```typescript
// apps/api-server/orval.config.ts
import { defineConfig } from 'orval';

export default defineConfig({
  api: {
    input: {
      target: 'http://localhost:3000/doc', // OpenAPI JSON 端点
    },
    output: {
      target: '../miniprogram/src/lib/api.ts', // 生成到小程序目录
      client: 'axios', // 或自定义适配器（适配 wx.request）
      override: {
        mutator: {
          path: '../miniprogram/src/lib/api-client.ts', // 自定义请求适配器
        },
      },
    },
  },
});
```

**小程序使用生成的 SDK：**

```typescript
// apps/miniprogram/src/pages/profile/index.ts
import { getUser } from '@/lib/api'; // Orval 生成的 SDK

Page({
  async onLoad() {
    const user = await getUser(); // 完全类型安全
    this.setData({ user });
  },
});
```

### 5.3 "No Manual Zod" 规则（核心原则）

**禁止手动定义 Zod Schema，必须从 `@repo/db` 派生。**

#### ❌ 错误示例（手动定义）

```typescript
// ❌ 禁止：手动定义与 DB 表结构重复的 Zod Schema
const userResponseSchema = z.object({
  id: z.string(),
  nickname: z.string(),
  avatar: z.string().optional(),
});
```

#### ✅ 正确示例（从 DB 派生）

```typescript
// ✅ 正确：从 DB Schema 派生
import { selectUserSchema } from '@repo/db';

// 方式 1：直接使用（隐藏敏感字段）
const userResponseSchema = selectUserSchema.omit({ password: true });

// 方式 2：选择部分字段
const userProfileSchema = selectUserSchema.pick({ id: true, nickname: true, avatar: true });

// 方式 3：扩展字段（添加计算字段）
const userWithStatsSchema = selectUserSchema.extend({
  activityCount: z.number(),
  followerCount: z.number(),
});

// 方式 4：数组响应
const userListSchema = z.array(selectUserSchema);
```

**唯一例外：纯瞬态参数（不来自数据库）**

```typescript
// ✅ 允许：查询参数、分页参数等瞬态数据
const paginationSchema = z.object({
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
});

const searchQuerySchema = z.object({
  keyword: z.string().min(1).max(100),
});
```

### 5.4 中间件架构

```typescript
// apps/api-server/src/middleware/auth.ts
import { jwt } from 'hono/jwt';

export const authMiddleware = jwt({
  secret: process.env.JWT_SECRET!,
  cookie: 'token', // 从 Cookie 读取（小程序也可设置）
});

// 使用
app.use('/users/*', authMiddleware);
app.use('/activities/*', authMiddleware);
```

```typescript
// apps/api-server/src/middleware/error.ts
import { HTTPException } from 'hono/http-exception';

export const errorHandler = async (c, next) => {
  try {
    await next();
  } catch (err) {
    if (err instanceof HTTPException) {
      return c.json({ code: err.status, msg: err.message }, err.status);
    }
    return c.json({ code: 500, msg: 'Internal Server Error' }, 500);
  }
};

app.use('*', errorHandler);
```

---

## 6. Admin Console 架构（Next.js 15 + Server Actions）

### 6.1 直接访问 Services（无 HTTP 开销）

Admin Console **不通过 API Server**，而是直接调用 `@repo/services`，实现零 HTTP 开销。

```typescript
// apps/admin-web/app/api/users/actions.ts
'use server';

import { UserService } from '@repo/services';
import { getSession } from '@/lib/session'; // Iron-Session

export async function getUserList(page: number, limit: number) {
  const session = await getSession();
  if (!session?.isAdmin) {
    throw new Error('Unauthorized');
  }
  
  const userService = new UserService();
  return await userService.list({ page, limit }); // 直接调用，无 HTTP
}
```

```typescript
// apps/admin-web/app/(dashboard)/users/page.tsx
import { getUserList } from '@/app/api/users/actions';

export default async function UsersPage() {
  const users = await getUserList(1, 20); // Server Component 直接调用
  return <UsersTable users={users} />;
}
```

### 6.2 Iron-Session 认证

```typescript
// apps/admin-web/lib/session.ts
import { getIronSession } from 'iron-session';
import { cookies } from 'next/headers';

export async function getSession() {
  const cookieStore = await cookies();
  return getIronSession(cookieStore, {
    password: process.env.SESSION_SECRET!,
    cookieName: 'admin-session',
  });
}

export async function requireAuth() {
  const session = await getSession();
  if (!session?.userId) {
    redirect('/login');
  }
  return session;
}
```

```typescript
// apps/admin-web/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  const session = request.cookies.get('admin-session');
  if (!session && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  return NextResponse.next();
}
```

---

## 7. 关键业务模块实现方案

### 7.1 数据流架构 (Database First → drizzle-zod → Services → API)

**核心流程：DB Schema → Zod Schema → Service Logic → API Contract**

#### 步骤 1：定义数据库 Schema

```typescript
// packages/db/src/schema/users.ts
import { pgTable, uuid, varchar, timestamp, integer } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  wxOpenId: varchar('wx_openid', { length: 128 }).notNull().unique(),
  nickname: varchar('nickname', { length: 50 }),
  avatar: varchar('avatar', { length: 500 }),
  creditScore: integer('credit_score').notNull().default(100), // 单一信用分 0-100
  createdAt: timestamp('created_at').defaultNow(),
});

// ✅ 立即导出 Zod Schema（使用 drizzle-zod）
export const insertUserSchema = createInsertSchema(users, {
  nickname: (schema) => schema.min(1).max(50),
});
export const selectUserSchema = createSelectSchema(users);

// 导出 TypeScript 类型
export type InsertUser = z.infer<typeof insertUserSchema>;
export type SelectUser = z.infer<typeof selectUserSchema>;
```

#### 步骤 2：Service 层使用生成的 Zod Schema

```typescript
// packages/services/src/users/service.ts
import { db, users, insertUserSchema, selectUserSchema } from '@repo/db';
import { eq } from 'drizzle-orm';

export class UserService {
  async createUser(data: z.infer<typeof insertUserSchema>) {
    // ✅ 使用从 DB 生成的 Schema 进行验证
    const validated = insertUserSchema.parse(data);
    const [user] = await db.insert(users).values(validated).returning();
    return user; // 类型为 SelectUser
  }

  async getById(id: string) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    if (!user) throw new Error('User not found');
    return user; // 类型为 SelectUser
  }
}
```

#### 步骤 3：API 层使用 Zod Schema 定义 OpenAPI 路由

```typescript
// apps/api-server/src/routes/users.ts
import { createRoute } from '@hono/zod-openapi';
import { selectUserSchema, insertUserSchema } from '@repo/db';
import { UserService } from '@repo/services';

const createUserRoute = createRoute({
  method: 'post',
  path: '/users',
  request: {
    body: {
      content: {
        'application/json': {
          schema: insertUserSchema.omit({ id: true, createdAt: true }), // 从 DB Schema 派生
        },
      },
    },
  },
  responses: {
    200: {
      description: '创建成功',
      content: {
        'application/json': {
          schema: selectUserSchema, // 从 DB Schema 派生
        },
      },
    },
  },
});

export const createUserHandler = async (c) => {
  const data = await c.req.json();
  const userService = new UserService();
  const user = await userService.createUser(data);
  return c.json(user);
};
```

### 7.2 资产体系与双账本设计

**设计原则**：多资产类型 + 双账本审计（余额账本 + 流水账本）。

#### 数据库 Schema

```typescript
// packages/db/src/schema/user_assets.ts
import { pgTable, uuid, integer, jsonb } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const userAssets = pgTable('user_assets', {
  userId: uuid('user_id').notNull().references(() => users.id),
  assetId: assetIdEnum('asset_id').notNull(), // 'coin', 'point', 'speed_match_card' 等
  category: assetCategoryEnum('category').notNull(), // 'currency', 'consumable', 'badge'
  balance: integer('balance').notNull().default(0),
  metadata: jsonb('metadata'),
}, (t) => [
  primaryKey({ columns: [t.userId, t.assetId] }),
]);

export const insertUserAssetSchema = createInsertSchema(userAssets);
export const selectUserAssetSchema = createSelectSchema(userAssets);
```

```typescript
// packages/db/src/schema/asset_records.ts
export const assetRecords = pgTable('asset_records', {
  id: bigint('id', { mode: 'number' }).primaryKey().generatedAlwaysAsIdentity(),
  userId: uuid('user_id').notNull().references(() => users.id),
  assetId: assetIdEnum('asset_id').notNull(),
  amount: integer('amount').notNull(), // 正数为获取，负数为消耗
  balanceSnapshot: integer('balance_snapshot').notNull(), // 变动后的余额快照
  reason: assetChangeReasonEnum('reason').notNull(), // 'recharge', 'payment_use', 'check_in' 等
  relatedOrderId: uuid('related_order_id').references(() => orders.id),
  description: text('description'),
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertAssetRecordSchema = createInsertSchema(assetRecords);
export const selectAssetRecordSchema = createSelectSchema(assetRecords);
```

#### Service 层实现

```typescript
// packages/services/src/assets/service.ts
import { db, userAssets, assetRecords } from '@repo/db';
import { eq, sql } from 'drizzle-orm';

export class AssetService {
  async addAsset(
    tx: any,
    userId: string,
    assetId: string,
    amount: number,
    reason: string,
    orderId?: string
  ) {
    // 更新或插入余额
    await tx.insert(userAssets).values({
      userId,
      assetId,
      category: this.getCategory(assetId),
      balance: amount,
    }).onConflictDoUpdate({
      target: [userAssets.userId, userAssets.assetId],
      set: { balance: sql`${userAssets.balance} + ${amount}` },
    });
    
    // 获取最新余额作为快照
    const [latest] = await tx.select().from(userAssets)
      .where(
        and(
          eq(userAssets.userId, userId),
          eq(userAssets.assetId, assetId)
        )
      );
    const balanceSnapshot = latest?.balance || amount;
    
    // 插入流水记录
    await tx.insert(assetRecords).values({
      userId,
      assetId,
      amount,
      balanceSnapshot,
      reason,
      relatedOrderId: orderId,
    });
  }

  async getBalance(userId: string, assetId: string) {
    const [asset] = await db.select().from(userAssets)
      .where(
        and(
          eq(userAssets.userId, userId),
          eq(userAssets.assetId, assetId)
        )
      );
    return asset?.balance || 0;
  }
}
```

### 7.3 LBS 社交与"她模式" (PostGIS)

```typescript
// packages/db/src/schema/activities.ts
import { geometry } from 'drizzle-orm/pg-core';

export const activities = pgTable('activities', {
  id: uuid('id').primaryKey().defaultRandom(),
  title: varchar('title', { length: 100 }).notNull(),
  location: geometry('location', { type: 'point', srid: 4326 }).notNull(), // PostGIS
  isFemaleFriendly: boolean('is_female_friendly').default(false),
  riskLevel: varchar('risk_level', { length: 10 }).default('low'),
  hostId: uuid('host_id').notNull().references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
});
```

```typescript
// packages/services/src/activities/service.ts
import { sql } from 'drizzle-orm';

export class ActivityService {
  /**
   * 查找附近活动（支持地图聚合）
   * 使用 PostGIS 的 ST_ClusterDBSCAN 进行空间聚类，减少地图标记数量
   */
  async findNearby(params: {
    lat: number;
    lng: number;
    radius: number; // 米
    sheMode?: boolean;
    clusterDistance?: number; // 聚合距离（米），默认 100m
  }) {
    const clusterDist = params.clusterDistance || 100;
    
    // 基础查询：距离筛选
    let baseQuery = db.select({
      id: activities.id,
      title: activities.title,
      location: activities.location,
      hostId: activities.hostId,
      riskLevel: activities.riskLevel,
      isFemaleFriendly: activities.isFemaleFriendly,
      // 计算距离
      distance: sql<number>`ST_Distance(
        location::geometry,
        ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry
      )`,
    }).from(activities)
      .where(
        sql`ST_DWithin(
          location::geometry,
          ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry,
          ${params.radius}
        )`
      );

    // 她模式过滤
    if (params.sheMode) {
      baseQuery = baseQuery.where(
        sql`risk_level = 'low' AND is_female_friendly = true`
      );
    }

    // 使用 PostGIS 聚合：ST_ClusterDBSCAN
    // 将距离 < clusterDist 的活动聚合成一个标记
    const clusteredQuery = sql`
      WITH clustered AS (
        SELECT 
          *,
          ST_ClusterDBSCAN(location::geometry, ${clusterDist}, 1) 
            OVER (ORDER BY ST_Distance(
              location::geometry,
              ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry
            )) AS cluster_id
        FROM activities
        WHERE ST_DWithin(
          location::geometry,
          ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry,
          ${params.radius}
        )
        ${params.sheMode ? sql`AND risk_level = 'low' AND is_female_friendly = true` : sql``}
      )
      SELECT 
        cluster_id,
        COUNT(*) as activity_count,
        ST_AsGeoJSON(ST_Centroid(ST_Collect(location::geometry))) as cluster_center
      FROM clustered
      GROUP BY cluster_id
    `;

    // 返回聚合结果（用于地图标记）
    return await db.execute(clusteredQuery);
  }

  /**
   * 获取聚合内的活动详情（点击聚合标记时调用）
   */
  async getActivitiesInCluster(params: {
    lat: number;
    lng: number;
    clusterDistance: number;
  }) {
    return await db.select().from(activities)
      .where(
        sql`ST_DWithin(
          location::geometry,
          ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry,
          ${params.clusterDistance}
        )`
      );
  }
}
```

### 7.4 AI 流式对话 (Streamed SSE)

**核心特性**：Hono 原生支持 SSE (Server-Sent Events)，用于 AI 对话的实时流式输出。

#### 数据库 Schema（AI 对话）

```typescript
// packages/db/src/schema/ai_conversations.ts
import { pgTable, uuid, varchar, timestamp, text } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const aiConversations = pgTable('ai_conversations', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id),
  title: varchar('title', { length: 100 }), // 对话标题（自动生成）
  createdAt: timestamp('created_at').defaultNow(),
});

export const aiMessages = pgTable('ai_messages', {
  id: uuid('id').primaryKey().defaultRandom(),
  conversationId: uuid('conversation_id').notNull().references(() => aiConversations.id),
  role: varchar('role', { length: 20 }).notNull(), // 'user' | 'assistant' | 'system'
  content: text('content').notNull(), // Markdown 格式
  metadata: jsonb('metadata'), // 存储结构化数据（如报告卡片）
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertAiMessageSchema = createInsertSchema(aiMessages);
export const selectAiMessageSchema = createSelectSchema(aiMessages);
```

#### API 路由定义（流式响应）

```typescript
// apps/api-server/src/routes/ai.ts
import { createRoute, z } from '@hono/zod-openapi';
import { streamSSE } from 'hono/streaming';
import { streamText } from 'ai/sdk'; // 使用 Vercel AI SDK

const chatRoute = createRoute({
  method: 'post',
  path: '/ai/chat',
  summary: 'AI 对话（流式输出）',
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        'application/json': {
          schema: z.object({
            message: z.string().min(1).max(2000),
            conversationId: z.string().uuid().optional(), // 新对话时为空
          }),
        },
      },
    },
  },
  responses: {
    200: {
      description: '流式响应（SSE）',
      content: {
        'text/event-stream': {
          schema: z.string(), // SSE 格式：data: {...}\n\n
        },
      },
    },
  },
});

export const chatHandler = async (c) => {
  const userId = c.get('userId');
  const { message, conversationId } = await c.req.json();
  
  // 使用 Hono 的 streamSSE 包装 AI SDK
  return streamSSE(c, async (stream) => {
    const result = await streamText({
      model: openai('gpt-4'),
      messages: [
        { role: 'system', content: '你是一个友好的AI助手，帮助用户找搭子...' },
        { role: 'user', content: message },
      ],
      onFinish: async (result) => {
        // 保存对话记录
        await saveMessage({
          conversationId: conversationId || await createConversation(userId),
          role: 'assistant',
          content: result.text,
          metadata: result.metadata, // 结构化数据（报告卡片）
        });
      },
    });

    // 流式输出
    for await (const chunk of result.textStream) {
      await stream.writeSSE({
        data: JSON.stringify({ type: 'text', content: chunk }),
      });
    }

    // 如果生成了结构化报告，发送卡片数据
    if (result.metadata?.cardType) {
      await stream.writeSSE({
        data: JSON.stringify({
          type: 'card',
          cardType: result.metadata.cardType,
          data: result.metadata.cardData,
        }),
      });
    }

    await stream.writeSSE({ data: '[DONE]' });
  });
};
```

#### 前端 CUI 渲染引擎

```typescript
// apps/miniprogram/src/components/cui-renderer/index.ts
/**
 * CUI 渲染引擎：解析流式 Markdown 并渲染为结构化卡片
 * 支持：文本流、报告卡片、图表等
 */
export class CUIRenderer {
  private markdownParser: MarkdownParser;
  
  constructor() {
    this.markdownParser = new MarkdownParser();
  }

  /**
   * 处理 SSE 流式数据
   */
  async handleStream(stream: ReadableStream) {
    const reader = stream.getReader();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = new TextDecoder().decode(value);
      buffer += chunk;

      // 解析 SSE 格式：data: {...}\n\n
      const lines = buffer.split('\n\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = JSON.parse(line.slice(6));
          await this.renderChunk(data);
        }
      }
    }
  }

  /**
   * 渲染单个数据块
   */
  private async renderChunk(data: { type: string; content?: string; cardType?: string; data?: any }) {
    if (data.type === 'text') {
      // 解析 Markdown 并追加到消息流
      const html = this.markdownParser.parse(data.content);
      this.appendToMessage(html);
    } else if (data.type === 'card') {
      // 渲染结构化卡片
      this.renderCard(data.cardType, data.data);
    }
  }

  /**
   * 渲染报告卡片（匹配分析、活动策划等）
   */
  private renderCard(cardType: string, data: any) {
    switch (cardType) {
      case 'match_analysis':
        return this.renderMatchAnalysisCard(data);
      case 'activity_plan':
        return this.renderActivityPlanCard(data);
      case 'relationship_diagnosis':
        return this.renderRelationshipCard(data);
      default:
        console.warn('Unknown card type:', cardType);
    }
  }
}
```

### 7.5 签到系统 (Check-in with Geofencing)

**核心特性**：基于 PostGIS 的地理围栏校验，支持 GPS 和二维码两种签到方式。

#### 数据库 Schema（Participants + Check-in）

```typescript
// packages/db/src/schema/participants.ts
import { pgTable, uuid, varchar, timestamp, geometry, pgEnum } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

// 签到状态枚举
export const checkInStatusEnum = pgEnum('check_in_status', [
  'pending',  // 待签到
  'gps',      // GPS 签到成功
  'qr',       // 二维码签到成功
  'missed',   // 未签到
]);

export const participants = pgTable('participants', {
  id: uuid('id').primaryKey().defaultRandom(),
  activityId: uuid('activity_id').notNull().references(() => activities.id),
  userId: uuid('user_id').notNull().references(() => users.id),
  status: varchar('status', { length: 20 }).notNull(), // 'pending' | 'approved' | 'rejected'
  checkInStatus: checkInStatusEnum('check_in_status').default('pending'),
  checkInLocation: geometry('check_in_location', { type: 'point', srid: 4326 }), // PostGIS Point
  checkInTime: timestamp('check_in_time'),
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertParticipantSchema = createInsertSchema(participants);
export const selectParticipantSchema = createSelectSchema(participants);
```

#### Service 层实现（地理围栏校验）

```typescript
// packages/services/src/activities/check-in.ts
import { db, participants, activities } from '@repo/db';
import { sql, eq, and } from 'drizzle-orm';

export class CheckInService {
  /**
   * GPS 签到（地理围栏校验）
   * @param activityId 活动 ID
   * @param userId 用户 ID
   * @param userLat 用户当前纬度
   * @param userLng 用户当前经度
   * @param geofenceRadius 围栏半径（米），默认 200m
   */
  async checkInWithGPS(params: {
    activityId: string;
    userId: string;
    userLat: number;
    userLng: number;
    geofenceRadius?: number;
  }) {
    const radius = params.geofenceRadius || 200;

    // 1. 获取活动地点
    const [activity] = await db.select({
      location: activities.location,
      startTime: activities.startTime,
      endTime: activities.endTime,
    })
      .from(activities)
      .where(eq(activities.id, params.activityId));

    if (!activity) {
      throw new Error('Activity not found');
    }

    // 2. 校验时间窗口（活动开始 ±30 分钟）
    const now = new Date();
    const startWindow = new Date(activity.startTime);
    startWindow.setMinutes(startWindow.getMinutes() - 30);
    const endWindow = new Date(activity.endTime);
    endWindow.setMinutes(endWindow.getMinutes() + 30);

    if (now < startWindow || now > endWindow) {
      throw new Error('Check-in time window expired');
    }

    // 3. PostGIS 地理围栏校验
    const distanceQuery = sql`
      ST_Distance(
        ${activity.location}::geometry,
        ST_SetSRID(ST_MakePoint(${params.userLng}, ${params.userLat}), 4326)::geometry
      )
    `;

    const [distanceResult] = await db.execute(sql`
      SELECT ${distanceQuery} as distance
    `);

    const distance = distanceResult.distance; // 米

    if (distance > radius) {
      throw new Error(`距离活动地点 ${Math.round(distance)} 米，超出围栏范围（${radius} 米）`);
    }

    // 4. 更新签到状态
    await db.update(participants)
      .set({
        checkInStatus: 'gps',
        checkInLocation: sql`ST_SetSRID(ST_MakePoint(${params.userLng}, ${params.userLat}), 4326)`,
        checkInTime: sql`NOW()`,
      })
      .where(
        and(
          eq(participants.activityId, params.activityId),
          eq(participants.userId, params.userId)
        )
      );

    return { success: true, distance: Math.round(distance) };
  }

  /**
   * 二维码签到（发起者扫描参与者动态码）
   */
  async checkInWithQR(params: {
    activityId: string;
    userId: string;
    qrCode: string; // 动态生成的二维码
  }) {
    // 验证二维码有效性（包含 activityId + userId + timestamp）
    // ... 二维码解析逻辑

    // 更新签到状态
    await db.update(participants)
      .set({
        checkInStatus: 'qr',
        checkInTime: sql`NOW()`,
      })
      .where(
        and(
          eq(participants.activityId, params.activityId),
          eq(participants.userId, params.userId)
        )
      );

    return { success: true };
  }
}
```

#### API 路由定义

```typescript
// apps/api-server/src/routes/activities/check-in.ts
import { createRoute, z } from '@hono/zod-openapi';
import { CheckInService } from '@repo/services';

const checkInRoute = createRoute({
  method: 'post',
  path: '/activities/{id}/check-in',
  summary: '活动签到（地理围栏校验）',
  security: [{ Bearer: [] }],
  request: {
    params: z.object({
      id: z.string().uuid(),
    }),
    body: {
      content: {
        'application/json': {
          schema: z.object({
            method: z.enum(['gps', 'qr']),
            lat: z.number().optional(), // GPS 方式必填
            lng: z.number().optional(), // GPS 方式必填
            qrCode: z.string().optional(), // QR 方式必填
          }),
        },
      },
    },
  },
  responses: {
    200: {
      description: '签到成功',
      content: {
        'application/json': {
          schema: z.object({
            success: z.boolean(),
            distance: z.number().optional(), // GPS 方式返回距离
          }),
        },
      },
    },
    400: {
      description: '签到失败（超出围栏/时间窗口）',
    },
  },
});

export const checkInHandler = async (c) => {
  const activityId = c.req.param('id');
  const userId = c.get('userId');
  const { method, lat, lng, qrCode } = await c.req.json();

  const checkInService = new CheckInService();

  if (method === 'gps') {
    if (!lat || !lng) {
      return c.json({ error: 'GPS 签到需要提供 lat 和 lng' }, 400);
    }
    const result = await checkInService.checkInWithGPS({
      activityId,
      userId,
      userLat: lat,
      userLng: lng,
    });
    return c.json(result);
  } else if (method === 'qr') {
    if (!qrCode) {
      return c.json({ error: '二维码签到需要提供 qrCode' }, 400);
    }
    const result = await checkInService.checkInWithQR({
      activityId,
      userId,
      qrCode,
    });
    return c.json(result);
  }

  return c.json({ error: 'Invalid check-in method' }, 400);
};
```

```typescript
// apps/api-server/src/routes/ai.ts
import { streamText } from 'ai'; // 使用 Vercel AI SDK

const chatRoute = createRoute({
  method: 'post',
  path: '/ai/chat',
  request: {
    body: {
      content: {
        'application/json': {
          schema: z.object({
            message: z.string(),
          }),
        },
      },
    },
  },
});

export const chatHandler = async (c) => {
  const { message } = await c.req.json();
  const userId = c.get('userId');
  
  // 使用流式响应
  return streamText({
    model: openai('gpt-4'),
    messages: [
      { role: 'system', content: '你是一个友好的AI助手...' },
      { role: 'user', content: message },
    ],
  });
};
```

---

## 8. 数据与安全架构

### 8.1 数据库 Schema (Drizzle + drizzle-zod)

**核心原则：每个表定义后立即导出 Zod Schema。**

```typescript
// packages/db/src/schema/users.ts
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const users = pgTable('users', {
  // ... 表定义
});

// ✅ 立即导出（必须）
export const insertUserSchema = createInsertSchema(users, {
  // 可以在这里添加验证规则
  nickname: (schema) => schema.min(1).max(50),
});
export const selectUserSchema = createSelectSchema(users);
```

```typescript
// packages/db/src/index.ts
// 统一导出所有 Schema 和 Zod
export * from './schema/users';
export * from './schema/activities';
export * from './schema/products';
// ... 其他表
```

### 8.2 内容安全风控 (红线)

```typescript
// packages/services/src/utils/content-check.ts
import { tencentIMS } from '@repo/utils';

export async function checkContent(text?: string, image?: string) {
  if (text) {
    const result = await tencentIMS.checkText(text);
    if (!result.pass) {
      throw new Error('内容不符合规范');
    }
  }
  if (image) {
    const result = await tencentIMS.checkImage(image);
    if (!result.pass) {
      throw new Error('图片不符合规范');
    }
  }
}
```

**强制执行点：**
- 创建活动 API
- 修改资料 API
- 发布评论 API
- **必须**先 `await checkContent()`，通过后才能写入数据库。

---

## 9. 开发与构建流程

### 9.1 开发环境 (Dev)

**命令**：`pnpm dev` (根目录)

1. **Turbo** 并行启动任务。
2. **Hono API Server**: `tsx watch src/index.ts` 启动，直接运行 TS。
3. **Next.js Admin**: `next dev` 启动，支持 App Router 和 Server Actions。
4. **Miniprogram**: `weapp-vite` 启动，监听文件变化 → 编译原生代码（零运行时开销）→ 输出到 `dist/`。
5. **API 文档**: 访问 `http://localhost:3000/reference` 查看 Scalar 文档。
6. **生成 SDK**: `pnpm orval` 从 OpenAPI 生成客户端 SDK。

### 9.2 生产部署 (Build)

**命令**：`pnpm build`

1. **Next.js Admin**: 构建优化后的生产包。
2. **Hono API Server**: 构建 Docker 镜像，部署到 VPS Node.js。
3. **Miniprogram**: `weapp-vite` 执行生产构建（压缩、去无用代码），生成优化后的 `dist` 包 → 上传微信后台。
4. **生成 SDK**: 生产环境构建时自动运行 `orval` 生成最新 SDK。

---

## 10. 环境变量管理

### 10.1 根目录环境变量 (.env.example)

```bash
# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/juchang

# Redis
REDIS_URL=redis://localhost:6379

# API Server
API_PORT=3000
JWT_SECRET=your_jwt_secret_here

# Admin Console
SESSION_SECRET=your_session_secret_here

# WeChat
WECHAT_APP_ID=your_wechat_app_id
WECHAT_APP_SECRET=your_wechat_app_secret

# AI
AI_API_KEY=your_ai_api_key

# 腾讯云内容安全
TENCENT_IMS_SECRET_ID=your_secret_id
TENCENT_IMS_SECRET_KEY=your_secret_key
```

### 10.2 Docker环境变量 (docker/.env.example)

```bash
# PostgreSQL
POSTGRES_DB=juchang
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_secure_password_here
POSTGRES_PORT=5432

# Redis
REDIS_PORT=6379
```

---

## 11. 总结

这套架构方案（V5.1 对齐 PRD V7.0）完美契合了**"Map-First + CUI-First"**的核心需求：

1. **Hono**: 轻量级、高性能的 API 网关，原生支持 SSE 流式输出，替代重型 NestJS。
2. **Database First**: `drizzle-zod` 实现 Single Source of Truth，禁止手动定义 Zod。
3. **Spec-Coding**: OpenAPI + Scalar + Orval 实现契约驱动开发。
4. **双轨架构**: Hono API (JWT) + Next.js Admin (Iron-Session)，职责清晰。
5. **原生小程序**: weapp-vite 支持原生开发，零运行时开销，保持极致的移动端性能。
6. **Map-First**: PostGIS `ST_ClusterDBSCAN` 聚合查询，优化地图首页标记性能。
7. **CUI-First**: 前端 CUI 渲染引擎，支持流式 Markdown 解析和结构化卡片渲染。
8. **信用系统简化**: 单一 `credit_score` 字段（0-100），无复杂积分表。
9. **签到系统**: PostGIS 地理围栏校验，支持 GPS 和二维码双模式。
10. **Turborepo + Internal Packages**: 实现真正的全栈逻辑复用。

这是一个**现代化、极简、类型安全、易于维护**的工业级全栈架构，完美支撑 PRD V7.0 的用户旅程驱动设计。
