这份 **《聚场 (Juchang) - 现代化全栈架构方案 V6.0 (Dev Ready)》** 是基于我们多轮深度讨论，并完成与 **PRD V8.2** 对齐后的最新定稿。

采用了 **"原生小程序 + Next.js Admin + Hono API + Drizzle ORM"** 的现代化全栈架构，同时利用 **Monorepo** 和 **Internal Packages** 实现了后端与前端、Web 与小程序之间的逻辑复用。

---

# 聚场 (Juchang) - 总体技术架构方案 (V6.0 对齐 PRD V8.2)

## 1. 核心设计理念

1. **原生极致性能**：小程序端完全放弃 React/Vue 运行时，使用 **weapp-vite** 编译原生 `WXML/WXSS/TS`。**核心价值**：weapp-vite 不仅提供编译能力，更重要的是支持原生开发的高性能（零运行时开销、直接调用微信原生 API），确保启动速度和运行性能达到"天花板"级别。
2. **数据库优先 (Database First)**：`@repo/db` (Drizzle ORM) 是绝对的数据源。所有 Zod Schema 必须通过 `drizzle-zod` 自动生成，**禁止手动定义 Zod**（除非是纯瞬态参数）。
3. **Spec-Coding 契约驱动**：使用 `@hono/zod-openapi` 定义路由契约，集成 **Scalar** 提供美观的 API 文档，使用 **Orval** 自动生成客户端 SDK。
4. **双轨架构 (Dual-Track)**：
   - **API Server (Hono)**：服务微信小程序，认证使用 **JWT**。
   - **Admin Console (Vite SPA)**：服务管理员，通过 **Eden Treaty** 调用 Elysia API，使用 **TanStack React Query** 管理数据状态。
5. **逻辑高度复用**：采用 **Monorepo (Internal Packages)** 策略，核心业务逻辑（用户管理、LBS算法、支付、AI）封装为纯 TS 源码包，API端、Web端和小程序端**直接引用源码**，无中间编译产物。
6. **类型安全优先**：从数据库到API到前端，全链路TypeScript，结合 **Drizzle ORM** 和 **drizzle-zod** 实现端到端的类型安全。
7. **极简主义 (Geek/Minimalist)**：移除 NestJS 等重型框架，采用 Hono 的轻量级中间件模式，代码简洁、性能卓越。

---

## 2. 技术栈全景图 (Tech Stack)

| 模块           | 选型                           | 核心理由                                                                     |
| :------------- | :----------------------------- | :--------------------------------------------------------------------------- |
| **代码管理**   | **Turborepo + Bun Workspaces** | 任务编排与依赖管理，支持源码引用的 Workspace 模式，Bun 提供毫秒级启动速度。                          |
| **代码质量**   | **Biome**                      | 极速的 Linter + Formatter，替代 ESLint + Prettier。                         |
| **小程序构建** | **weapp-vite (Native)**        | **核心变革点**。使用 Vite 编译原生小程序，支持 TS、SCSS，零运行时开销。 |
| **Admin后台**  | **Vite + TanStack Router + React Query** | 现代化 SPA 架构，通过 Eden Treaty 调用 API，shadcn/ui 组件库。 |
| **API网关**    | **Hono**                       | 符合 Web Standards 的高性能后端，运行在 VPS Node.js（非 Edge），类型推断极致。 |
| **API文档**    | **Scalar**                     | 基于 OpenAPI 的现代化 API 文档界面，集成 `@scalar/hono-api-reference`。 |
| **客户端SDK**  | **Orval**                      | 从 OpenAPI Spec 自动生成 TypeScript 客户端 SDK，小程序直接使用生成的 SDK。 |
| **数据库**     | **PostgreSQL + PostGIS + pgvector**       | 处理 LBS 社交（附近的人、地理围栏、距离计算）与 AI RAG 向量检索的行业标准组合。                    |
| **ORM**        | **Drizzle ORM**                | TypeScript Native，无运行时开销，生成高效 SQL。                             |
| **Schema生成** | **drizzle-zod**                | **核心**：从 Drizzle Schema 自动生成 Zod Schema，实现 Single Source of Truth。 |
| **模式验证**   | **Zod**                        | TypeScript优先的模式验证库，与Drizzle完美集成，实现端到端类型安全。        |
| **基础设施**   | **Redis + Docker**             | 缓存与容器化部署。                                                           |
| **AI/风控**    | **LLM API + 腾讯云 IMS**       | 通过 Hono 流式输出 AI 响应；强制接入第三方内容安全服务。                     |

---

## 3. 系统逻辑架构图

```mermaid
graph TD
    subgraph "Client Side (前端应用)"
        MP[微信小程序 (Native + Vite)<br/>Map-First + CUI-First]
        Admin[管理后台 (Vite + TanStack + Eden Treaty)]
        CUI[CUI 渲染引擎<br/>Markdown → 结构化卡片]
    end

    subgraph "API Server (Hono)"
        API[Hono API Gateway<br/>JWT Auth<br/>OpenAPI + Scalar]
        SDK[Orval 生成 SDK]
        SSE[SSE 流式输出<br/>AI Chat Stream]
    end

    subgraph "Shared Logic Layer (纯 TS 源码包)"
        Services[Services层 (用户/LBS/AI/支付)]
        DB[Database层 (Drizzle + drizzle-zod)]
        Utils[通用工具 (Format/Validator)]
      LBS[LBS 聚合引擎<br/>PostGIS Cluster + pgvector]
    end

    subgraph "Data Layer (基础设施)"
    PostgreSQL[(PostgreSQL + PostGIS + pgvector<br/>ST_ClusterDBSCAN)]
        Redis[(Redis Cache)]
        LLM[大模型 API]
        RiskAPI[腾讯云内容安全]
    end

    %% 编译时依赖 (Build Time)
    MP -.->|Vite 编译引入| Services & Utils
    Admin -->|Eden Treaty| API
    SDK -.->|从 OpenAPI 生成| API
    CUI -.->|Markdown 解析| MP

    %% 运行时依赖 (Runtime)
    API -->|Import| Services
    Admin -->|React Query| Admin
    Services -->|Drizzle ORM| DB
    DB -->|SQL| PostgreSQL
    Services -->|PostGIS 聚合查询| LBS
    LBS -->|聚合结果| PostgreSQL
    
    MP -->|HTTPS / 使用 SDK| API
    Admin -->|Zustand Auth| Admin

    %% 数据流向
    Services -->|Cache| Redis
    API -->|SSE Stream| SSE
    SSE -->|流式输出| MP
    MP -->|解析 Markdown| CUI
    Services -->|Content Check| RiskAPI
    Services -->|AI Stream| LLM

    %% Schema 生成流
    DB -.->|drizzle-zod| Services
    Services -.->|Zod Schema| API
```

**核心数据流：**
1. **Database First**：`@repo/db` 定义表结构 → `drizzle-zod` 生成 Zod Schema → `@repo/services` 使用生成的 Schema → `apps/api` 使用 Zod 定义 OpenAPI 路由。
2. **Admin 通过 API 访问**：Vite Admin 通过 Eden Treaty 调用 Elysia API，享受完整的类型安全。

---

## 4. 目录结构设计 (Internal Packages 模式)

所有 `packages/*` 均配置为 **No-Build** 模式（`main` 指向 `.ts`），由上层应用（Apps）的 Vite/Next.js 负责编译。

```text
/root
  ├── apps/
  │    ├── miniprogram/             # [WeChat 原生] Vite+TS 工程
  │    │    ├── src/
  │    │    │    ├── pages/
  │    │    │    │    ├── home/     # 地图首页 (Map-First 核心)
  │    │    │    │    ├── ai/       # AI 助手 (CUI-First 核心)
  │    │    │    │    ├── message/  # 消息列表/聊天
  │    │    │    │    ├── me/       # 个人中心
  │    │    │    │    ├── activity/ # 活动详情/创建/评价
  │    │    │    │    ├── search/   # 独立搜索页
  │    │    │    │    └── webview/  # 仅协议/政策承载
  │    │    │    ├── components/
  │    │    │    │    └── cui-renderer/  # CUI 渲染引擎 (Markdown → 卡片)
  │    │    │    ├── lib/            # 使用 Orval 生成的 SDK
  │    │    │    └── utils/          # 直接 import @repo/services
  │    │    ├── vite.config.ts
  │    │    └── tsconfig.json
  │    │
  │    ├── admin/                   # [Vite + React] 管理后台
  │    │    ├── src/
  │    │    │    ├── features/     # 功能模块（users, activities, dashboard）
  │    │    │    ├── routes/       # TanStack Router 文件路由
  │    │    │    ├── components/   # 通用组件（shadcn/ui）
  │    │    │    ├── hooks/        # 通用 hooks
  │    │    │    └── lib/          # Eden Treaty 客户端
  │    │    ├── vite.config.ts
  │    │    └── package.json
  │    │
  │    └── api/              # [Hono] API Gateway（服务小程序）
  │
  ├── packages/
  │    ├── db/                      # Drizzle ORM + drizzle-zod
  │    │    ├── drizzle.config.ts
  │    │    ├── src/
  │    │    │    ├── db.ts          # 数据库客户端
  │    │    │    ├── migrate.ts     # 迁移脚本
  │    │    │    ├── index.ts       # 导出所有 Schema 和 Zod
  │    │    │    └── schema/
  │    │    │         ├── enums.ts
  │    │    │         ├── users.ts / user_auths.ts
  │    │    │         ├── activities.ts / participants.ts
  │    │    │         ├── products.ts / orders.ts / payments.ts
  │    │    │         ├── user_assets.ts / asset_records.ts
  │    │    │         └── ai_messages.ts / ai_conversations.ts
  │    │    └── package.json
  │    │
  │    ├── services/                # 领域服务层（纯 TS）
  │    │    ├── src/
  │    │    │    ├── auth/
  │    │    │    ├── users/
  │    │    │    ├── activities/
  │    │    │    ├── products/
  │    │    │    ├── orders/
  │    │    │    ├── payments/
  │    │    │    ├── assets/
  │    │    │    └── ai.ts / lbs.ts / utils.ts
  │    │    └── package.json
  │    │
  │    ├── utils/                   # 通用工具包 (格式化 / 加解密)
  │    └── ts-config/               # 统一 TypeScript 配置
  │
  ├── docker/                      # 基础设施（Postgres + Redis）
  │    ├── docker-compose.yml
  │    ├── postgres/               # 自定义镜像 + init SQL
  │    └── .env.example
  │
  ├── turbo.json                   # Turborepo pipeline
  ├── bun.lockb                    # Bun lockfile (二进制格式，需提交)
  └── .env.example                 # 根环境变量模板
```

---

## 5. API 应用层架构（Hono 版）

### 5.1 目录结构

> 下方为当前实际 `apps/api` 目录的抽象化结构示意（以模块划分为主），便于与实现对齐。

```
apps/api/
├── src/
│   ├── index.ts                     # 应用入口：创建 OpenAPIHono 实例、挂载模块、启动 Scalar 文档与 Node Server
│   ├── modules/                     # [路由+OpenAPI 模块层]
│   │   ├── users/
│   │   │   ├── users.routes.ts      # 使用 createRoute 定义 /users 路由与 OpenAPI 契约
│   │   │   └── users.openapi.ts     # （可选）拆分出的 OpenAPI 规范或编排
│   │   └── activities/              # 活动模块（预留）
│   │
│   ├── guards/                      # [守卫层]
│   │   └── risk.guard.ts            # 风险控制守卫（可对接腾讯 IMS、信用分等）
│   │
│   ├── interceptors/                # [拦截器层]
│   │   ├── logging.interceptor.ts   # 请求日志
│   │   └── transform.interceptor.ts # 统一响应结构转换
│   │
│   ├── pipes/                       # [参数管道层]
│   │   └── pagination.pipe.ts       # 分页参数解析与验证
│   │
│   └── schedules/                   # [定时任务层]
│       ├── index.ts                 # 初始化所有定时任务
│       ├── anchor.schedule.ts       # 幽灵锚点 / 运营脚本相关定时任务
│       └── cleanup.schedule.ts      # 过期活动 / 群聊清理等后台任务
│
├── orval.config.ts                  # Orval 配置（从 OpenAPI 生成 SDK）
├── package.json
└── tsconfig.json
```

### 5.2 核心工作流：Spec-Coding

**"Spec-Coding"** 是指先定义 OpenAPI 契约，再实现业务逻辑的开发模式。

#### 步骤 1：定义路由契约（使用 `@hono/zod-openapi`）

```typescript
// apps/api/src/routes/users.ts
import { createRoute, z } from '@hono/zod-openapi';
import { selectUserSchema } from '@repo/db'; // 从 DB 自动生成的 Zod Schema

// 定义路由契约
const getUserRoute = createRoute({
  method: 'get',
  path: '/users/me',
  summary: '获取当前用户信息',
  security: [{ Bearer: [] }], // 需要 JWT
  responses: {
    200: {
      description: '用户信息',
      content: {
        'application/json': {
          schema: selectUserSchema.omit({ password: true }), // 从 DB Schema 派生，隐藏密码
        },
      },
    },
  },
});

// 实现路由处理器
export const getUserHandler = async (c) => {
  const userId = c.get('userId'); // 从 JWT 中间件获取
  const userService = new UserService();
  const user = await userService.getById(userId);
  return c.json(user);
};
```

#### 步骤 2：注册路由到 Hono App

```typescript
// apps/api/src/app.ts
import { OpenAPIHono } from '@hono/zod-openapi';
import { apiReference } from '@scalar/hono-api-reference';
import { getUserRoute, getUserHandler } from './routes/users';

const app = new OpenAPIHono();

// 注册路由
app.openapi(getUserRoute, getUserHandler);

// 集成 Scalar 文档
app.get('/reference', apiReference({
  theme: 'purple',
  spec: {
    url: '/doc', // OpenAPI JSON 端点
  },
}));

// 导出 OpenAPI JSON
app.doc('/doc', {
  openapi: '3.0.0',
  info: {
    title: '聚场 API',
    version: '1.0.0',
  },
});

export default app;
```

#### 步骤 3：使用 Orval 生成客户端 SDK

```typescript
// apps/api/orval.config.ts
import { defineConfig } from 'orval';

export default defineConfig({
  api: {
    input: {
      target: 'http://localhost:3000/doc', // OpenAPI JSON 端点
    },
    output: {
      target: '../miniprogram/src/lib/api.ts', // 生成到小程序目录
      client: 'axios', // 或自定义适配器（适配 wx.request）
      override: {
        mutator: {
          path: '../miniprogram/src/lib/api-client.ts', // 自定义请求适配器
        },
      },
    },
  },
});
```

**小程序使用生成的 SDK：**

```typescript
// apps/miniprogram/src/pages/profile/index.ts
import { getUser } from '@/lib/api'; // Orval 生成的 SDK

Page({
  async onLoad() {
    const user = await getUser(); // 完全类型安全
    this.setData({ user });
  },
});
```

### 5.3 "No Manual Zod" 规则（核心原则）

**禁止手动定义 Zod Schema，必须从 `@repo/db` 派生。**

#### ❌ 错误示例（手动定义）

```typescript
// ❌ 禁止：手动定义与 DB 表结构重复的 Zod Schema
const userResponseSchema = z.object({
  id: z.string(),
  nickname: z.string(),
  avatar: z.string().optional(),
});
```

#### ✅ 正确示例（从 DB 派生）

```typescript
// ✅ 正确：从 DB Schema 派生
import { selectUserSchema } from '@repo/db';

// 方式 1：直接使用（隐藏敏感字段）
const userResponseSchema = selectUserSchema.omit({ password: true });

// 方式 2：选择部分字段
const userProfileSchema = selectUserSchema.pick({ id: true, nickname: true, avatar: true });

// 方式 3：扩展字段（添加计算字段）
const userWithStatsSchema = selectUserSchema.extend({
  activityCount: z.number(),
  followerCount: z.number(),
});

// 方式 4：数组响应
const userListSchema = z.array(selectUserSchema);
```

**唯一例外：纯瞬态参数（不来自数据库）**

```typescript
// ✅ 允许：查询参数、分页参数等瞬态数据
const paginationSchema = z.object({
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
});

const searchQuerySchema = z.object({
  keyword: z.string().min(1).max(100),
});
```

### 5.4 中间件架构

```typescript
// apps/api/src/middleware/auth.ts
import { jwt } from 'hono/jwt';

export const authMiddleware = jwt({
  secret: process.env.JWT_SECRET!,
  cookie: 'token', // 从 Cookie 读取（小程序也可设置）
});

// 使用
app.use('/users/*', authMiddleware);
app.use('/activities/*', authMiddleware);
```

```typescript
// apps/api/src/middleware/error.ts
import { HTTPException } from 'hono/http-exception';

export const errorHandler = async (c, next) => {
  try {
    await next();
  } catch (err) {
    if (err instanceof HTTPException) {
      return c.json({ code: err.status, msg: err.message }, err.status);
    }
    return c.json({ code: 500, msg: 'Internal Server Error' }, 500);
  }
};

app.use('*', errorHandler);
```

```typescript
// apps/api/src/middleware/risk-control.ts
import { checkContent } from '@repo/services/utils/content-check';
import type { MiddlewareHandler } from 'hono';

/**
 * 风控中间件：在进入业务路由前拦截敏感内容
 * - 强制拦截：POST /activities、POST /messages
 * - 使用腾讯云 IMS（封装在 checkContent 中）
 */
export const riskControlMiddleware: MiddlewareHandler = async (c, next) => {
  if (c.req.method === 'POST') {
    const url = new URL(c.req.url);
    const path = url.pathname;

    if (path.startsWith('/activities') || path.startsWith('/messages')) {
      const body = await c.req.json().catch(() => ({}));
      // 文本内容可能来自 title/description/message 等字段
      const text =
        body.title ??
        body.description ??
        body.message ??
        body.content ??
        '';

      // 统一走腾讯云 IMS 风控
      await checkContent(text);
    }
  }

  await next();
};

// 注册顺序：auth → risk-control → 业务路由
app.use('*', authMiddleware);
app.use('*', riskControlMiddleware);
app.use('*', errorHandler);
```

---

## 6. Admin Console 架构（Vite + TanStack Router + React Query）

### 6.1 技术栈

Admin Console 采用现代化 SPA 架构，通过 Eden Treaty 调用 Elysia API：

| 技术 | 用途 |
|------|------|
| **Vite** | 构建工具，毫秒级 HMR |
| **React 19** | UI 框架 |
| **TanStack Router** | 文件路由，类型安全 |
| **TanStack React Query** | 数据获取、缓存、乐观更新 |
| **Eden Treaty** | 类型安全的 API 客户端 |
| **shadcn/ui** | UI 组件库 |
| **Zod** | 前端表单验证 |

### 6.2 目录结构

```
apps/admin/
├── src/
│   ├── features/           # 功能模块（Feature-based）
│   │   ├── users/
│   │   │   ├── index.tsx           # 页面组件
│   │   │   ├── data/
│   │   │   │   ├── schema.ts       # Zod schemas
│   │   │   │   ├── data.ts         # 静态数据（选项、样式）
│   │   │   │   └── users.ts        # API 调用（Eden Treaty）
│   │   │   ├── hooks/
│   │   │   │   └── use-users.ts    # React Query hooks
│   │   │   └── components/
│   │   │       ├── users-table.tsx
│   │   │       ├── users-columns.tsx
│   │   │       └── users-dialogs.tsx
│   │   └── activities/
│   │       └── ...
│   ├── routes/             # TanStack Router 文件路由
│   │   ├── __root.tsx
│   │   └── _authenticated/
│   │       ├── users/
│   │       └── activities/
│   ├── lib/
│   │   └── eden.ts         # Eden Treaty 客户端
│   └── components/         # 通用组件
└── package.json
```

### 6.3 Eden Treaty 客户端

```typescript
// apps/admin/src/lib/eden.ts
import { treaty } from '@elysiajs/eden'
import type { App } from '@juchang/api'

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000'

export const api = treaty<App>(API_BASE_URL)
```

### 6.4 API 调用层

```typescript
// apps/admin/src/features/users/data/users.ts
import { api } from '@/lib/eden'
import type { User, UserListResponse } from './schema'

export async function fetchUsers(params: { page?: number; limit?: number }) {
  const { data, error } = await api.users.get({ query: params })
  if (error) throw new Error(error.value?.msg || '获取用户列表失败')
  return data as UserListResponse
}

export async function updateUser(id: string, body: { nickname?: string }) {
  const { data, error } = await api.users({ id }).put(body)
  if (error) throw new Error(error.value?.msg || '更新用户失败')
  return data as User
}
```

### 6.5 React Query Hooks

```typescript
// apps/admin/src/features/users/hooks/use-users.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { toast } from 'sonner'
import { fetchUsers, updateUser } from '../data/users'

export const userKeys = {
  all: ['users'] as const,
  list: (params: object) => [...userKeys.all, 'list', params] as const,
}

export function useUsers(params = {}) {
  return useQuery({
    queryKey: userKeys.list(params),
    queryFn: () => fetchUsers(params),
  })
}

export function useUpdateUser() {
  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: ({ id, data }) => updateUser(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all })
      toast.success('用户更新成功')
    },
  })
}
```

### 6.6 页面组件

```typescript
// apps/admin/src/features/users/index.tsx
import { useUsers } from './hooks/use-users'
import { UsersTable } from './components/users-table'

export function Users() {
  const { data, isLoading, isError } = useUsers({ page: 1, limit: 20 })

  if (isLoading) return <Skeleton />
  if (isError) return <ErrorAlert />

  return <UsersTable data={data?.data || []} />
}
```

### 6.7 运营功能

Admin Console 承担「运营中枢」角色：

- **用户管理**：查看、编辑、封禁/解封、删除用户
- **活动管理**：审核高风险活动、管理幽灵锚点
- **数据看板**：用户增长、活动统计、收入报表

---

## 7. 关键业务模块实现方案

### 7.1 数据流架构 (Database First → drizzle-zod → Services → API)

**核心流程：DB Schema → Zod Schema → Service Logic → API Contract**

#### 步骤 1：定义数据库 Schema

```typescript
// packages/db/src/schema/users.ts
import { pgTable, uuid, varchar, timestamp, integer, jsonb } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  wxOpenId: varchar('wx_openid', { length: 128 }).notNull().unique(),
  nickname: varchar('nickname', { length: 50 }),
  avatar: varchar('avatar', { length: 500 }),
  creditScore: integer('credit_score').notNull().default(100), // 单一信用分 0-100
  // 聚合后的性格/氛围标签（来自活动评价与群聊互动）
  vibeTags: jsonb('vibe_tags').$type<string[] | null>(),
  // 徽章墙（如「高信用搭子」「高频主持人」等）
  badges: jsonb('badges').$type<string[] | null>(),
  createdAt: timestamp('created_at').defaultNow(),
});

// ✅ 立即导出 Zod Schema（使用 drizzle-zod）
export const insertUserSchema = createInsertSchema(users, {
  nickname: (schema) => schema.min(1).max(50),
});
export const selectUserSchema = createSelectSchema(users);

// 导出 TypeScript 类型
export type InsertUser = z.infer<typeof insertUserSchema>;
export type SelectUser = z.infer<typeof selectUserSchema>;
```

#### 步骤 2：Service 层使用生成的 Zod Schema

```typescript
// packages/services/src/users/service.ts
import { db, users, insertUserSchema, selectUserSchema } from '@repo/db';
import { eq } from 'drizzle-orm';

export class UserService {
  async createUser(data: z.infer<typeof insertUserSchema>) {
    // ✅ 使用从 DB 生成的 Schema 进行验证
    const validated = insertUserSchema.parse(data);
    const [user] = await db.insert(users).values(validated).returning();
    return user; // 类型为 SelectUser
  }

  async getById(id: string) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    if (!user) throw new Error('User not found');
    return user; // 类型为 SelectUser
  }
}
```

#### 步骤 3：API 层使用 Zod Schema 定义 OpenAPI 路由

```typescript
// apps/api/src/routes/users.ts
import { createRoute } from '@hono/zod-openapi';
import { selectUserSchema, insertUserSchema } from '@repo/db';
import { UserService } from '@repo/services';

const createUserRoute = createRoute({
  method: 'post',
  path: '/users',
  request: {
    body: {
      content: {
        'application/json': {
          schema: insertUserSchema.omit({ id: true, createdAt: true }), // 从 DB Schema 派生
        },
      },
    },
  },
  responses: {
    200: {
      description: '创建成功',
      content: {
        'application/json': {
          schema: selectUserSchema, // 从 DB Schema 派生
        },
      },
    },
  },
});

export const createUserHandler = async (c) => {
  const data = await c.req.json();
  const userService = new UserService();
  const user = await userService.createUser(data);
  return c.json(user);
};
```

### 7.2 资产体系与双账本设计

**设计原则**：多资产类型 + 双账本审计（余额账本 + 流水账本）。

#### 数据库 Schema

```typescript
// packages/db/src/schema/user_assets.ts
import { pgTable, uuid, integer, jsonb } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const userAssets = pgTable('user_assets', {
  userId: uuid('user_id').notNull().references(() => users.id),
  assetId: assetIdEnum('asset_id').notNull(), // 'coin', 'point', 'speed_match_card' 等
  category: assetCategoryEnum('category').notNull(), // 'currency', 'consumable', 'badge'
  balance: integer('balance').notNull().default(0),
  metadata: jsonb('metadata'),
}, (t) => [
  primaryKey({ columns: [t.userId, t.assetId] }),
]);

export const insertUserAssetSchema = createInsertSchema(userAssets);
export const selectUserAssetSchema = createSelectSchema(userAssets);
```

```typescript
// packages/db/src/schema/asset_records.ts
export const assetRecords = pgTable('asset_records', {
  id: bigint('id', { mode: 'number' }).primaryKey().generatedAlwaysAsIdentity(),
  userId: uuid('user_id').notNull().references(() => users.id),
  assetId: assetIdEnum('asset_id').notNull(),
  amount: integer('amount').notNull(), // 正数为获取，负数为消耗
  balanceSnapshot: integer('balance_snapshot').notNull(), // 变动后的余额快照
  reason: assetChangeReasonEnum('reason').notNull(), // 'recharge', 'payment_use', 'check_in' 等
  relatedOrderId: uuid('related_order_id').references(() => orders.id),
  description: text('description'),
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertAssetRecordSchema = createInsertSchema(assetRecords);
export const selectAssetRecordSchema = createSelectSchema(assetRecords);
```

### 7.3 评价体系与氛围标签 (Reviews + Vibe Tags)

**设计目标**：通过活动结束后的评价与群聊行为，沉淀用户「氛围/性格标签」与徽章，用于后续匹配体验和风控。

#### 数据库 Schema（Reviews）

```typescript
// packages/db/src/schema/reviews.ts
import { pgTable, uuid, integer, text, timestamp, jsonb } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const reviews = pgTable('reviews', {
  id: uuid('id').primaryKey().defaultRandom(),
  activityId: uuid('activity_id').notNull().references(() => activities.id),
  reviewerId: uuid('reviewer_id').notNull().references(() => users.id),
  targetUserId: uuid('target_user_id').notNull().references(() => users.id),
  rating: integer('rating').notNull(), // 1-5 星
  // 结构化标签（如：守时、活跃、情绪稳定、聊得来）
  tags: jsonb('tags').$type<string[]>(),
  comment: text('comment'),
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertReviewSchema = createInsertSchema(reviews);
export const selectReviewSchema = createSelectSchema(reviews);
```

#### Service 层：聚合出用户 vibeTags / badges

```typescript
// packages/services/src/reviews/vibe.service.ts
import { db, reviews, users } from '@repo/db';
import { eq, sql } from 'drizzle-orm';

export class VibeService {
  /**
   * 聚合某个用户的氛围标签与徽章，并回写到 users 表：
   * - users.vibeTags：高频出现的评价标签（如「守时」「好沟通」）
   * - users.badges：根据评价与参与行为生成的徽章（如「高信用搭子」）
   */
  async aggregateUserVibe(userId: string) {
    const result = await db.execute(sql`
      SELECT
        jsonb_agg(tags) AS all_tags
      FROM reviews
      WHERE target_user_id = ${userId}
    `);

    const allTags: string[] =
      (result.rows?.[0]?.all_tags as string[][] | null)?.flat() ?? [];

    const topTags = Array.from(
      new Map(allTags.map((t) => [t, (allTags.filter((x) => x === t).length)]))
    )
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([tag]) => tag as string);

    const badges: string[] = [];
    if (topTags.includes('守时')) badges.push('punctual_partner');
    if (topTags.includes('好沟通')) badges.push('easygoing_partner');

    await db
      .update(users)
      .set({
        vibeTags: topTags,
        badges,
      })
      .where(eq(users.id, userId));

    return { vibeTags: topTags, badges };
  }
}

#### Service 层实现

```typescript
// packages/services/src/assets/service.ts
import { db, userAssets, assetRecords } from '@repo/db';
import { eq, sql } from 'drizzle-orm';

export class AssetService {
  async addAsset(
    tx: any,
    userId: string,
    assetId: string,
    amount: number,
    reason: string,
    orderId?: string
  ) {
    // 更新或插入余额
    await tx.insert(userAssets).values({
      userId,
      assetId,
      category: this.getCategory(assetId),
      balance: amount,
    }).onConflictDoUpdate({
      target: [userAssets.userId, userAssets.assetId],
      set: { balance: sql`${userAssets.balance} + ${amount}` },
    });
    
    // 获取最新余额作为快照
    const [latest] = await tx.select().from(userAssets)
      .where(
        and(
          eq(userAssets.userId, userId),
          eq(userAssets.assetId, assetId)
        )
      );
    const balanceSnapshot = latest?.balance || amount;
    
    // 插入流水记录
    await tx.insert(assetRecords).values({
      userId,
      assetId,
      amount,
      balanceSnapshot,
      reason,
      relatedOrderId: orderId,
    });
  }

  async getBalance(userId: string, assetId: string) {
    const [asset] = await db.select().from(userAssets)
      .where(
        and(
          eq(userAssets.userId, userId),
          eq(userAssets.assetId, assetId)
        )
      );
    return asset?.balance || 0;
  }
}
```

### 7.4 LBS 社交与"她模式" (PostGIS)

```typescript
// packages/db/src/schema/activities.ts
import { geometry, boolean, integer } from 'drizzle-orm/pg-core';
import { vector } from 'drizzle-orm-pgvector';

export const activities = pgTable('activities', {
  id: uuid('id').primaryKey().defaultRandom(),
  title: varchar('title', { length: 100 }).notNull(),
  location: geometry('location', { type: 'point', srid: 4326 }).notNull(), // PostGIS
  // 幽灵锚点：用于运营官方虚拟点位（如商圈推荐、城市活动墙）
  isGhost: boolean('is_ghost').notNull().default(false),
  isFemaleFriendly: boolean('is_female_friendly').default(false),
  riskLevel: varchar('risk_level', { length: 10 }).default('low'),
  // 「她模式」风险分：越高越不安全，用于 LBS + AI 综合过滤
  riskScore: integer('risk_score').notNull().default(0),
  // 活动描述/标题的语义向量，用于 AI RAG 搜索（基于 pgvector）
  embedding: vector('embedding', { dimensions: 1636 }),
  hostId: uuid('host_id').notNull().references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
});
```

```typescript
// packages/services/src/activities/service.ts
import { sql } from 'drizzle-orm';

export class ActivityService {
  /**
   * 查找附近活动（支持地图聚合）
   * 使用 PostGIS 的 ST_ClusterDBSCAN 进行空间聚类，减少地图标记数量
   * 同时结合 riskScore / isFemaleFriendly 做「她模式」过滤
   */
  async findNearby(params: {
    lat: number;
    lng: number;
    radius: number; // 米
    sheMode?: boolean;
    clusterDistance?: number; // 聚合距离（米），默认 100m
  }) {
    const clusterDist = params.clusterDistance || 100;
    
    // 基础查询：距离筛选
    let baseQuery = db.select({
      id: activities.id,
      title: activities.title,
      location: activities.location,
      hostId: activities.hostId,
      riskLevel: activities.riskLevel,
      isFemaleFriendly: activities.isFemaleFriendly,
      // 计算距离
      distance: sql<number>`ST_Distance(
        location::geometry,
        ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry
      )`,
    }).from(activities)
      .where(
        sql`ST_DWithin(
          location::geometry,
          ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry,
          ${params.radius}
        )`
      );

    // 她模式过滤
    if (params.sheMode) {
      baseQuery = baseQuery.where(
        sql`risk_level = 'low' AND is_female_friendly = true`
      );
    }

    // 使用 PostGIS 聚合：ST_ClusterDBSCAN
    // 将距离 < clusterDist 的活动聚合成一个标记
    const clusteredQuery = sql`
      WITH clustered AS (
        SELECT 
          *,
          ST_ClusterDBSCAN(location::geometry, ${clusterDist}, 1) 
            OVER (ORDER BY ST_Distance(
              location::geometry,
              ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry
            )) AS cluster_id
        FROM activities
        WHERE ST_DWithin(
          location::geometry,
          ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry,
          ${params.radius}
        )
        ${params.sheMode ? sql`AND risk_level = 'low' AND is_female_friendly = true` : sql``}
      )
      SELECT 
        cluster_id,
        COUNT(*) as activity_count,
        ST_AsGeoJSON(ST_Centroid(ST_Collect(location::geometry))) as cluster_center
      FROM clustered
      GROUP BY cluster_id
    `;

    // 返回聚合结果（用于地图标记）
    return await db.execute(clusteredQuery);
  }

  /**
   * 获取聚合内的活动详情（点击聚合标记时调用）
   */
  async getActivitiesInCluster(params: {
    lat: number;
    lng: number;
    clusterDistance: number;
  }) {
    return await db.select().from(activities)
      .where(
        sql`ST_DWithin(
          location::geometry,
          ST_SetSRID(ST_MakePoint(${params.lng}, ${params.lat}), 4326)::geometry,
          ${params.clusterDistance}
        )`
      );
  }
}
```

### 7.5 AI 流式对话 + RAG 推荐 (Streamed SSE + pgvector)

在原有 AI 流式对话能力基础上，结合 `pgvector` 与 `activities.embedding` 字段，支持基于语义向量的 RAG（Retrieval-Augmented Generation）活动推荐：

```typescript
// packages/services/src/ai/activities-rag.service.ts
import { db, activities } from '@repo/db';
import { sql } from 'drizzle-orm';

export class AiActivitiesRagService {
  /**
   * 基于自然语言查询的活动召回（RAG 检索层）
   * - 使用 pgvector 对 query 向量与 activities.embedding 做相似度搜索
   * - 支持「她模式」过滤（riskScore / isFemaleFriendly / isGhost）
   */
  async searchActivitiesByEmbedding(params: {
    queryEmbedding: number[]; // 来自 LLM / Embedding API
    limit?: number;
    sheMode?: boolean;
  }) {
    const limit = params.limit ?? 20;

    return db.execute(sql`
      SELECT
        id,
        title,
        host_id,
        is_female_friendly,
        risk_level,
        risk_score,
        is_ghost,
        embedding <=> ${params.queryEmbedding}::vector AS distance
      FROM activities
      WHERE
        -- 幽灵锚点可以作为运营补充，但不作为主召回的唯一来源
        (is_ghost = false OR is_ghost = true)
        ${params.sheMode ? sql`AND risk_score <= 20 AND is_female_friendly = true` : sql``}
      ORDER BY embedding <=> ${params.queryEmbedding}::vector ASC
      LIMIT ${limit}
    `);
  }
}
```

### 7.6 消息与群聊：软删除与自动解散

**需求目标**：活动群聊为「临时型」社交空间，活动结束 24 小时后自动失效，降低长期社交压力与隐私风险。

#### 软删除 / 自动解散逻辑

```typescript
// packages/services/src/messages/group-lifecycle.service.ts
import { db, activities, groups, messages } from '@repo/db';
import { lt, and, eq, sql } from 'drizzle-orm';

export class GroupLifecycleService {
  /**
   * 定时任务：自动关闭已结束 24h 的活动群
   * - groups: 记录群状态（active / closed）
   * - messages: 采用软删除标记 is_deleted，前端不再展示
   */
  async autoCloseExpiredGroups() {
    // 1. 找到结束超过 24h 的活动
    const expiredActivities = await db
      .select({
        id: activities.id,
      })
      .from(activities)
      .where(
        lt(
          activities.endTime,
          sql`NOW() - INTERVAL '24 hours'`
        )
      );

    if (!expiredActivities.length) return;

    const activityIds = expiredActivities.map((a) => a.id);

    // 2. 关闭对应群聊
    await db
      .update(groups)
      .set({
        status: 'closed',
        closedAt: sql`NOW()`,
      })
      .where(sql`${groups.activityId} = ANY(${activityIds}::uuid[])`);

    // 3. 将群内消息标记为软删除（前端不再展示，但可用于风控审计）
    await db
      .update(messages)
      .set({
        isDeleted: true,
      })
      .where(
        and(
          sql`${messages.groupId} IN (SELECT id FROM ${groups} WHERE activity_id = ANY(${activityIds}::uuid[]))`,
          eq(messages.isDeleted, false)
        )
      );
  }
}
```

### 7.7 AI 流式对话 (Streamed SSE)

**核心特性**：Hono 原生支持 SSE (Server-Sent Events)，用于 AI 对话的实时流式输出。

#### 数据库 Schema（AI 对话）

```typescript
// packages/db/src/schema/ai_conversations.ts
import { pgTable, uuid, varchar, timestamp, text } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const aiConversations = pgTable('ai_conversations', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id),
  title: varchar('title', { length: 100 }), // 对话标题（自动生成）
  createdAt: timestamp('created_at').defaultNow(),
});

export const aiMessages = pgTable('ai_messages', {
  id: uuid('id').primaryKey().defaultRandom(),
  conversationId: uuid('conversation_id').notNull().references(() => aiConversations.id),
  role: varchar('role', { length: 20 }).notNull(), // 'user' | 'assistant' | 'system'
  content: text('content').notNull(), // Markdown 格式
  metadata: jsonb('metadata'), // 存储结构化数据（如报告卡片）
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertAiMessageSchema = createInsertSchema(aiMessages);
export const selectAiMessageSchema = createSelectSchema(aiMessages);
```

#### API 路由定义（流式响应）

```typescript
// apps/api/src/routes/ai.ts
import { createRoute, z } from '@hono/zod-openapi';
import { streamSSE } from 'hono/streaming';
import { streamText } from 'ai/sdk'; // 使用 Vercel AI SDK

const chatRoute = createRoute({
  method: 'post',
  path: '/ai/chat',
  summary: 'AI 对话（流式输出）',
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        'application/json': {
          schema: z.object({
            message: z.string().min(1).max(2000),
            conversationId: z.string().uuid().optional(), // 新对话时为空
          }),
        },
      },
    },
  },
  responses: {
    200: {
      description: '流式响应（SSE）',
      content: {
        'text/event-stream': {
          schema: z.string(), // SSE 格式：data: {...}\n\n
        },
      },
    },
  },
});

export const chatHandler = async (c) => {
  const userId = c.get('userId');
  const { message, conversationId } = await c.req.json();
  
  // 使用 Hono 的 streamSSE 包装 AI SDK
  return streamSSE(c, async (stream) => {
    const result = await streamText({
      model: openai('gpt-4'),
      messages: [
        { role: 'system', content: '你是一个友好的AI助手，帮助用户找搭子...' },
        { role: 'user', content: message },
      ],
      onFinish: async (result) => {
        // 保存对话记录
        await saveMessage({
          conversationId: conversationId || await createConversation(userId),
          role: 'assistant',
          content: result.text,
          metadata: result.metadata, // 结构化数据（报告卡片）
        });
      },
    });

    // 流式输出
    for await (const chunk of result.textStream) {
      await stream.writeSSE({
        data: JSON.stringify({ type: 'text', content: chunk }),
      });
    }

    // 如果生成了结构化报告，发送卡片数据
    if (result.metadata?.cardType) {
      await stream.writeSSE({
        data: JSON.stringify({
          type: 'card',
          cardType: result.metadata.cardType,
          data: result.metadata.cardData,
        }),
      });
    }

    await stream.writeSSE({ data: '[DONE]' });
  });
};
```

#### 前端 CUI 渲染引擎

```typescript
// apps/miniprogram/src/components/cui-renderer/index.ts
/**
 * CUI 渲染引擎：解析流式 Markdown 并渲染为结构化卡片
 * 支持：文本流、报告卡片、图表等
 */
export class CUIRenderer {
  private markdownParser: MarkdownParser;
  
  constructor() {
    this.markdownParser = new MarkdownParser();
  }

  /**
   * 处理 SSE 流式数据
   */
  async handleStream(stream: ReadableStream) {
    const reader = stream.getReader();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = new TextDecoder().decode(value);
      buffer += chunk;

      // 解析 SSE 格式：data: {...}\n\n
      const lines = buffer.split('\n\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = JSON.parse(line.slice(6));
          await this.renderChunk(data);
        }
      }
    }
  }

  /**
   * 渲染单个数据块
   */
  private async renderChunk(data: { type: string; content?: string; cardType?: string; data?: any }) {
    if (data.type === 'text') {
      // 解析 Markdown 并追加到消息流
      const html = this.markdownParser.parse(data.content);
      this.appendToMessage(html);
    } else if (data.type === 'card') {
      // 渲染结构化卡片
      this.renderCard(data.cardType, data.data);
    }
  }

  /**
   * 渲染报告卡片（匹配分析、活动策划等）
   */
  private renderCard(cardType: string, data: any) {
    switch (cardType) {
      case 'match_analysis':
        return this.renderMatchAnalysisCard(data);
      case 'activity_plan':
        return this.renderActivityPlanCard(data);
      case 'relationship_diagnosis':
        return this.renderRelationshipCard(data);
      default:
        console.warn('Unknown card type:', cardType);
    }
  }
}
```

### 7.8 签到系统 (Check-in with Geofencing)

**核心特性**：基于 PostGIS 的地理围栏校验，支持 GPS 和二维码两种签到方式。

#### 数据库 Schema（Participants + Check-in）

```typescript
// packages/db/src/schema/participants.ts
import { pgTable, uuid, varchar, timestamp, geometry, pgEnum } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

// 签到状态枚举
export const checkInStatusEnum = pgEnum('check_in_status', [
  'pending',  // 待签到
  'gps',      // GPS 签到成功
  'qr',       // 二维码签到成功
  'missed',   // 未签到
]);

export const participants = pgTable('participants', {
  id: uuid('id').primaryKey().defaultRandom(),
  activityId: uuid('activity_id').notNull().references(() => activities.id),
  userId: uuid('user_id').notNull().references(() => users.id),
  status: varchar('status', { length: 20 }).notNull(), // 'pending' | 'approved' | 'rejected'
  checkInStatus: checkInStatusEnum('check_in_status').default('pending'),
  checkInLocation: geometry('check_in_location', { type: 'point', srid: 4326 }), // PostGIS Point
  checkInTime: timestamp('check_in_time'),
  createdAt: timestamp('created_at').defaultNow(),
});

export const insertParticipantSchema = createInsertSchema(participants);
export const selectParticipantSchema = createSelectSchema(participants);
```

#### Service 层实现（地理围栏校验）

```typescript
// packages/services/src/activities/check-in.ts
import { db, participants, activities } from '@repo/db';
import { sql, eq, and } from 'drizzle-orm';

export class CheckInService {
  /**
   * GPS 签到（地理围栏校验）
   * @param activityId 活动 ID
   * @param userId 用户 ID
   * @param userLat 用户当前纬度
   * @param userLng 用户当前经度
   * @param geofenceRadius 围栏半径（米），默认 200m
   */
  async checkInWithGPS(params: {
    activityId: string;
    userId: string;
    userLat: number;
    userLng: number;
    geofenceRadius?: number;
  }) {
    const radius = params.geofenceRadius || 200;

    // 1. 获取活动地点
    const [activity] = await db.select({
      location: activities.location,
      startTime: activities.startTime,
      endTime: activities.endTime,
    })
      .from(activities)
      .where(eq(activities.id, params.activityId));

    if (!activity) {
      throw new Error('Activity not found');
    }

    // 2. 校验时间窗口（活动开始 ±30 分钟）
    const now = new Date();
    const startWindow = new Date(activity.startTime);
    startWindow.setMinutes(startWindow.getMinutes() - 30);
    const endWindow = new Date(activity.endTime);
    endWindow.setMinutes(endWindow.getMinutes() + 30);

    if (now < startWindow || now > endWindow) {
      throw new Error('Check-in time window expired');
    }

    // 3. PostGIS 地理围栏校验
    const distanceQuery = sql`
      ST_Distance(
        ${activity.location}::geometry,
        ST_SetSRID(ST_MakePoint(${params.userLng}, ${params.userLat}), 4326)::geometry
      )
    `;

    const [distanceResult] = await db.execute(sql`
      SELECT ${distanceQuery} as distance
    `);

    const distance = distanceResult.distance; // 米

    if (distance > radius) {
      throw new Error(`距离活动地点 ${Math.round(distance)} 米，超出围栏范围（${radius} 米）`);
    }

    // 4. 更新签到状态
    await db.update(participants)
      .set({
        checkInStatus: 'gps',
        checkInLocation: sql`ST_SetSRID(ST_MakePoint(${params.userLng}, ${params.userLat}), 4326)`,
        checkInTime: sql`NOW()`,
      })
      .where(
        and(
          eq(participants.activityId, params.activityId),
          eq(participants.userId, params.userId)
        )
      );

    return { success: true, distance: Math.round(distance) };
  }

  /**
   * 二维码签到（发起者扫描参与者动态码）
   */
  async checkInWithQR(params: {
    activityId: string;
    userId: string;
    qrCode: string; // 动态生成的二维码
  }) {
    // 验证二维码有效性（包含 activityId + userId + timestamp）
    // ... 二维码解析逻辑

    // 更新签到状态
    await db.update(participants)
      .set({
        checkInStatus: 'qr',
        checkInTime: sql`NOW()`,
      })
      .where(
        and(
          eq(participants.activityId, params.activityId),
          eq(participants.userId, params.userId)
        )
      );

    return { success: true };
  }
}
```

#### API 路由定义

```typescript
// apps/api/src/routes/activities/check-in.ts
import { createRoute, z } from '@hono/zod-openapi';
import { CheckInService } from '@repo/services';

const checkInRoute = createRoute({
  method: 'post',
  path: '/activities/{id}/check-in',
  summary: '活动签到（地理围栏校验）',
  security: [{ Bearer: [] }],
  request: {
    params: z.object({
      id: z.string().uuid(),
    }),
    body: {
      content: {
        'application/json': {
          schema: z.object({
            method: z.enum(['gps', 'qr']),
            lat: z.number().optional(), // GPS 方式必填
            lng: z.number().optional(), // GPS 方式必填
            qrCode: z.string().optional(), // QR 方式必填
          }),
        },
      },
    },
  },
  responses: {
    200: {
      description: '签到成功',
      content: {
        'application/json': {
          schema: z.object({
            success: z.boolean(),
            distance: z.number().optional(), // GPS 方式返回距离
          }),
        },
      },
    },
    400: {
      description: '签到失败（超出围栏/时间窗口）',
    },
  },
});

export const checkInHandler = async (c) => {
  const activityId = c.req.param('id');
  const userId = c.get('userId');
  const { method, lat, lng, qrCode } = await c.req.json();

  const checkInService = new CheckInService();

  if (method === 'gps') {
    if (!lat || !lng) {
      return c.json({ error: 'GPS 签到需要提供 lat 和 lng' }, 400);
    }
    const result = await checkInService.checkInWithGPS({
      activityId,
      userId,
      userLat: lat,
      userLng: lng,
    });
    return c.json(result);
  } else if (method === 'qr') {
    if (!qrCode) {
      return c.json({ error: '二维码签到需要提供 qrCode' }, 400);
    }
    const result = await checkInService.checkInWithQR({
      activityId,
      userId,
      qrCode,
    });
    return c.json(result);
  }

  return c.json({ error: 'Invalid check-in method' }, 400);
};
```

---

## 8. 数据与安全架构

### 8.1 数据库 Schema (Drizzle + drizzle-zod)

**核心原则：每个表定义后立即导出 Zod Schema。**

```typescript
// packages/db/src/schema/users.ts
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

export const users = pgTable('users', {
  // ... 表定义
});

// ✅ 立即导出（必须）
export const insertUserSchema = createInsertSchema(users, {
  // 可以在这里添加验证规则
  nickname: (schema) => schema.min(1).max(50),
});
export const selectUserSchema = createSelectSchema(users);
```

```typescript
// packages/db/src/index.ts
// 统一导出所有 Schema 和 Zod
export * from './schema/users';
export * from './schema/activities';
export * from './schema/products';
// ... 其他表
```

### 8.2 内容安全风控 (红线)

```typescript
// packages/services/src/utils/content-check.ts
import { tencentIMS } from '@repo/utils';

export async function checkContent(text?: string, image?: string) {
  if (text) {
    const result = await tencentIMS.checkText(text);
    if (!result.pass) {
      throw new Error('内容不符合规范');
    }
  }
  if (image) {
    const result = await tencentIMS.checkImage(image);
    if (!result.pass) {
      throw new Error('图片不符合规范');
    }
  }
}
```

**强制执行点：**
- 创建活动 API
- 修改资料 API
- 发布评论 API
- **必须**先 `await checkContent()`，通过后才能写入数据库。

---

## 9. 开发与构建流程

### 9.1 开发环境 (Dev)

**命令**：`bun run dev` (根目录)

1. **Turbo** 并行启动任务。
2. **ElysiaJS API Server**: `bun run --watch src/index.ts` 启动，使用 Bun 运行时直接运行 TS。
3. **Next.js Admin**: `next dev` 启动，支持 App Router 和 Server Actions。
4. **Miniprogram**: `weapp-vite` 启动，监听文件变化 → 编译原生代码（零运行时开销）→ 输出到 `dist/`。
5. **API 文档**: 访问 `http://localhost:3000/doc/json` 查看 OpenAPI JSON（Fumadocs 文档站待实现）。
6. **生成 SDK**: `bun run gen:api` 从 OpenAPI 生成客户端 SDK。

### 9.2 生产部署 (Build)

**命令**：`bun run build`

1. **Next.js Admin**: 构建优化后的生产包。
2. **ElysiaJS API Server**: 使用 `bun build` 构建，部署到 VPS Bun 运行时。
3. **Miniprogram**: `weapp-vite` 执行生产构建（压缩、去无用代码），生成优化后的 `dist` 包 → 上传微信后台。
4. **生成 SDK**: 生产环境构建时自动运行 `bun run gen:api` 生成最新 SDK。

---

## 10. 环境变量管理

### 10.1 根目录环境变量 (.env.example)

```bash
# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/juchang

# Redis
REDIS_URL=redis://localhost:6379

# API Server
API_PORT=3000
JWT_SECRET=your_jwt_secret_here

# Admin Console
SESSION_SECRET=your_session_secret_here

# WeChat
WECHAT_APP_ID=your_wechat_app_id
WECHAT_APP_SECRET=your_wechat_app_secret

# AI
AI_API_KEY=your_ai_api_key

# 腾讯云内容安全
TENCENT_IMS_SECRET_ID=your_secret_id
TENCENT_IMS_SECRET_KEY=your_secret_key
```

### 10.2 Docker环境变量 (docker/.env.example)

```bash
# PostgreSQL
POSTGRES_DB=juchang
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_secure_password_here
POSTGRES_PORT=5432

# Redis
REDIS_PORT=6379
```

---

## 11. 总结

这套架构方案（V6.0 对齐 PRD V8.2）完美契合了**"Map-First + CUI-First"**的核心需求：

1. **Hono**: 轻量级、高性能的 API 网关，原生支持 SSE 流式输出与 AI 对话流，替代重型 NestJS。
2. **Database First**: `drizzle-zod` 实现 Single Source of Truth，禁止手动定义 Zod，并引入 `pgvector` 支持 RAG 向量检索。
3. **Spec-Coding**: OpenAPI + Scalar + Orval 实现契约驱动开发，小程序通过自动生成的 SDK 访问 API。
4. **双轨架构**: Hono API (JWT) + Next.js Admin (Iron-Session)，职责清晰，同时承担幽灵锚点管理与高风险活动审查的运营中枢。
5. **原生小程序**: weapp-vite 支持原生开发，零运行时开销，保持极致的移动端性能。
6. **Map-First**: PostGIS `ST_ClusterDBSCAN` 聚合查询 + 「她模式」风险过滤（`riskScore` / `isFemaleFriendly`），优化地图首页标记性能与安全体验。
7. **CUI-First + AI**: 前端 CUI 渲染引擎，结合 AI 流式输出与 RAG 推荐，实现从文本到结构化卡片的智能交互。
8. **信用与氛围体系**: 以单一 `credit_score` 为基础，通过 Reviews → `vibeTags` → `badges` 的闭环，沉淀可解释的用户画像。
9. **消息与群聊治理**: 群聊基于软删除 / 自动解散机制，活动结束 24 小时后自动失效，降低长期社交与合规风险。
10. **签到系统**: PostGIS 地理围栏校验，支持 GPS 和二维码双模式，为线下活动提供可靠的出席凭证。
11. **Turborepo + Internal Packages**: 保持 apps/ 与 packages/ 的清晰边界，实现真正的全栈逻辑复用与高效开发。

这是一个**现代化、极简、类型安全、易于维护**的工业级全栈架构，完美支撑 PRD V8.2 的用户旅程设计与 AI 驱动体验。
