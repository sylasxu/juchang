# Requirements Document

## Introduction

活动语义推荐功能，通过 Embedding + 混合检索实现智能活动推荐。用户可以用自然语言描述想要的活动（如"轻松的小局"、"适合社恐的活动"、"周五晚上热闹的地方"），系统能理解语义并返回最匹配的结果。

这是聚场从"SQL 查询器"进化为"真正 Agent"的核心能力：
- **冷启动救命稻草**：数据少时，向量搜索能提升匹配率（"玩水"能匹配到"室内冲浪"）
- **模糊意图理解**：用户说"压力大想发呆"，能推荐"白噪音读书局"
- **千人千面**：记住用户喜欢"热闹+辣+晚上"，下次推荐"大排档啤酒局"

## Glossary

- **Embedding_Service**: 负责生成和管理活动文本向量的服务模块
- **Activity_Embedding**: 活动的向量表示，存储在 activities 表的 embedding 列（1024 维，对应智谱 embedding-3）
- **Enriched_Text**: 富集化的活动文本，包含标题、描述、类型、标签、时间、地点、氛围等信息
- **Semantic_Search**: 基于向量相似度的语义检索功能
- **Hybrid_Retrieval**: 结合硬过滤（SQL/PostGIS）和软排序（向量相似度）的混合召回策略
- **User_Interest_Vectors**: 用户最近满意活动的向量集合（非平均值），用于个性化推荐

## Requirements

### Requirement 1: Embedding 基础设施

**User Story:** As a developer, I want to store activity embeddings in the database, so that I can perform semantic search on activities.

#### Acceptance Criteria

1. THE Database SHALL have an `embedding` column of type `vector(1024)` in the `activities` table
2. THE Database SHALL have an HNSW index on the `embedding` column using `vector_cosine_ops` for efficient similarity search
3. WHEN the pgvector extension is not installed, THE System SHALL install it automatically during migration
4. THE Database migration SHALL be idempotent (safe to run multiple times)

### Requirement 2: Embedding 生成（富集化文本）

**User Story:** As a system, I want to automatically generate embeddings from enriched activity text, so that semantic search can match time/location/vibe queries.

#### Acceptance Criteria

1. WHEN an activity is created, THE Embedding_Service SHALL generate an embedding from Enriched_Text
2. THE Enriched_Text SHALL follow this format:
   ```
   标题: {title}
   描述: {description}
   类型: {type}
   标签: {tags.join(", ")}
   时间: {day_of_week} {time_of_day}
   地点: {locationName}
   氛围: {implied_vibe}
   ```
3. WHEN an activity's title, description, type, or tags are updated, THE Embedding_Service SHALL regenerate the embedding
4. THE Embedding_Service SHALL use existing `getZhipuEmbedding()` function from `models/adapters/zhipu.ts`
5. IF embedding generation fails, THEN THE System SHALL log the error and continue without blocking the activity creation
6. THE Embedding_Service SHALL infer `implied_vibe` from activity type and description (e.g., "热闹"、"安静"、"商务")
7. THE Embedding_Service SHALL convert startAt to human-readable format: day_of_week (周一-周日) + time_of_day (早上/下午/晚上/深夜)

### Requirement 3: 语义检索

**User Story:** As a user, I want to search activities using natural language, so that I can find activities that match my intent even without exact keywords.

#### Acceptance Criteria

1. WHEN a user queries with natural language, THE Semantic_Search SHALL embed the query using `getZhipuEmbedding()`
2. THE Semantic_Search SHALL calculate cosine similarity using pgvector's `<=>` operator
3. THE Semantic_Search SHALL return activities with similarity score above 0.5 (1 - cosine_distance > 0.5)
4. THE Semantic_Search SHALL order results by similarity score descending
5. THE Semantic_Search SHALL limit results to top 20 candidates

### Requirement 4: 混合检索（分级过滤策略）

**User Story:** As a user, I want search results that are both semantically relevant and practically feasible, so that I get useful recommendations.

#### Acceptance Criteria

1. THE Hybrid_Retrieval SHALL use a two-stage filtering strategy: Hard Filter (SQL) → Soft Rank (Vector)
2. **Hard Filter Stage**: THE Hybrid_Retrieval SHALL first apply SQL filters:
   - status = 'active'
   - start_at > NOW()
   - current_participants < max_participants
   - ST_DWithin(location, user_location, radius_meters) if user location is provided
3. **Soft Rank Stage**: THE Hybrid_Retrieval SHALL rank filtered results by cosine similarity
4. WHEN Hard Filter returns ≤ 3 results, THE Hybrid_Retrieval SHALL skip vector search and return results directly (save tokens)
5. WHEN no semantic query is provided, THE Hybrid_Retrieval SHALL fall back to distance-based ordering
6. THE Hybrid_Retrieval SHALL support optional type filter for activity type

### Requirement 5: 推荐理由生成

**User Story:** As a user, I want to understand why each activity was recommended, so that I can make better decisions.

#### Acceptance Criteria

1. THE System SHALL generate a `matchReason` field for each recommended activity
2. THE matchReason SHALL explain the semantic match (e.g., "推荐这个是因为你想找安静的地方，而这个活动描述里提到了'静谧'")
3. THE matchReason SHALL be generated by LLM based on: user query, activity details, similarity score
4. IF matchReason generation fails, THEN THE System SHALL return a default reason based on distance/time
5. THE matchReason generation SHALL be optional and configurable (可关闭以节省成本)

### Requirement 6: 用户兴趣向量（MaxSim 策略）

**User Story:** As a returning user, I want personalized recommendations based on my history, so that I see activities I'm likely to enjoy.

#### Acceptance Criteria

1. WHEN a user has participated in 3+ activities with positive feedback, THE System SHALL store their activity embeddings
2. THE System SHALL store up to 3 most recent satisfied activity embeddings in users.workingMemory (NOT average)
3. WHEN searching, THE Hybrid_Retrieval SHALL calculate similarity against each stored vector and use MaxSim (maximum similarity)
4. THE MaxSim score SHALL boost the final ranking score by up to 20%
5. WHEN a user has no history, THE System SHALL use preferences from workingMemory for personalization
6. THE System SHALL NOT store average vectors (避免"不伦不类"的中间点问题)

### Requirement 7: 批量 Embedding 回填

**User Story:** As a developer, I want to generate embeddings for existing activities, so that all activities are searchable after deployment.

#### Acceptance Criteria

1. THE System SHALL provide a script `scripts/backfill-embeddings.ts` to backfill embeddings for existing activities
2. THE Script SHALL process activities in batches of 100 to avoid rate limits
3. THE Script SHALL skip activities that already have embeddings (unless --force flag is provided)
4. THE Script SHALL log progress: processed count, skipped count, error count
5. THE Script SHALL be idempotent (safe to run multiple times)
6. THE Script SHALL support --dry-run flag to preview without making changes

### Requirement 8: exploreNearby Tool 升级

**User Story:** As a user, I want the AI assistant to understand my natural language queries when exploring activities, so that I get better recommendations.

#### Acceptance Criteria

1. THE exploreNearby Tool SHALL accept an optional `semanticQuery` parameter
2. WHEN semanticQuery is provided, THE Tool SHALL use Hybrid_Retrieval with semantic search
3. WHEN semanticQuery is not provided, THE Tool SHALL use existing SQL-only search
4. THE Tool SHALL return a `matchReason` field for each activity when semantic search is used
5. THE Tool response time SHALL not exceed 3 seconds
6. THE Tool SHALL gracefully degrade to SQL-only search if embedding service is unavailable

### Requirement 9: RAG 模块架构

**User Story:** As a developer, I want a modular RAG system following Mastra patterns, so that semantic search capabilities are well-organized and maintainable.

#### Acceptance Criteria

1. THE System SHALL create a new `rag/` submodule under `apps/api/src/modules/ai/`
2. THE RAG submodule SHALL follow this directory structure (与 Requirement 12 统一):
   ```
   ai/rag/
   ├── index.ts           # 模块导出
   ├── service.ts         # 核心服务 (search, indexActivity, deleteIndex)
   ├── utils.ts           # enrichText(), embed(), inferVibe()
   └── types.ts           # SearchParams, ScoredActivity, IndexItem
   ```
3. THE RAG submodule SHALL be independent and reusable (不依赖具体业务逻辑)
4. THE RAG submodule SHALL integrate with existing Memory module (共享 Embedding 模型配置)
5. THE RAG submodule SHALL expose clear interfaces:
   - `indexActivity(activity)` - 索引单个活动
   - `search(params: SearchParams)` - 混合检索
   - `deleteIndex(activityId)` - 删除索引
6. THE Activities module SHALL trigger RAG indexing on Create/Update events (异步，不阻塞主流程)
7. THE System SHALL update TAD.md architecture diagram to include RAG module

### Requirement 10: AI 架构图更新

**User Story:** As a developer, I want the architecture documentation to reflect the new RAG capabilities, so that the system design is clear.

#### Acceptance Criteria

1. THE TAD.md SHALL update the AI Module architecture diagram to include RAG module:
   ```
   ┌─────────────────────────────────────────────────────────────────┐
   │                     AI Module (AI 模块)                          │
   ├─────────────────────────────────────────────────────────────────┤
   │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
   │  │   Intent    │  │   Memory    │  │   Tools     │              │
   │  │  Classifier │  │   System    │  │  Registry   │              │
   │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘              │
   │         │                │                │                      │
   │  ┌──────▼────────────────▼────────────────▼──────┐              │
   │  │         AI Pipeline (AI 处理管道)              │              │
   │  └──────────────────────┬────────────────────────┘              │
   │                         │                                        │
   │  ┌─────────────┐  ┌─────▼─────┐  ┌─────────────┐              │
   │  │    RAG      │  │  Model    │  │  Prompts    │              │
   │  │   Engine    │  │  Router   │  │  (人设)     │              │
   │  │ 向量检索引擎 │  │ 模型路由   │  │             │              │
   │  └─────────────┘  └───────────┘  └─────────────┘              │
   │         ↑                                                        │
   │  ┌──────┴──────┐                                                │
   │  │  pgvector   │ ← HNSW Index                                   │
   │  │  (向量存储)  │                                                │
   │  └─────────────┘                                                │
   └─────────────────────────────────────────────────────────────────┘
   ```
2. THE TAD.md SHALL add a new section "6.X RAG 系统 (Retrieval-Augmented Generation)" documenting:
   - 模块结构
   - Embedding 生成流程
   - 混合检索流程 (Hard Filter → Soft Rank)
   - 与现有模块的集成点
3. THE Memory System section SHALL update "语义回忆" status from "❌ 未实现" to "✅ 已实现 (via RAG module)"
4. THE TAD.md SHALL include the RAG Pipeline sequence diagram showing:
   - 用户查询 → 意图识别 → Tool Call → RAG Search → 结果返回

### Requirement 11: 数据库 Schema 更新

**User Story:** As a developer, I want the database schema documented in TAD.md to include the embedding column, so that the data model is complete.

#### Acceptance Criteria

1. THE TAD.md activities table schema SHALL include the `embedding` column definition:
   ```typescript
   embedding: vector('embedding', { dimensions: 1024 }),
   ```
2. THE TAD.md SHALL document the pgvector extension requirement in database setup
3. THE TAD.md SHALL document the HNSW index configuration:
   ```typescript
   embeddingIndex: index('embedding_idx').using('hnsw', table.embedding.op('vector_cosine_ops'))
   ```
4. THE users.workingMemory schema SHALL document the `interestVectors` field for MaxSim:
   ```typescript
   interface EnhancedUserProfile {
     // ... existing fields
     interestVectors?: {
       activityId: string;
       embedding: number[];
       participatedAt: Date;
     }[];  // 最多存 3 个最近满意活动的向量
   }
   ```


### Requirement 12: RAG 子模块（ai/rag/）

**User Story:** As a developer, I want RAG capabilities as a submodule under AI, so that semantic search is tightly integrated with the AI pipeline.

#### Acceptance Criteria

1. THE System SHALL create RAG as a submodule at `apps/api/src/modules/ai/rag/`
2. THE RAG submodule directory structure SHALL be (与 Requirement 9 统一):
   ```
   ai/rag/
   ├── index.ts           # 模块导出
   ├── service.ts         # 核心服务 (search, indexActivity, deleteIndex)
   ├── utils.ts           # enrichText(), embed(), inferVibe()
   └── types.ts           # SearchParams, ScoredActivity, IndexItem
   ```
3. THE RAG submodule SHALL be reusable within the AI module
4. THE AI Tools (exploreNearby) SHALL call RAG service for semantic search
5. THE Activities module SHALL trigger RAG indexing on Create/Update events (异步，不阻塞主流程)

### Requirement 13: Agent 封装层（意图驱动的动态上下文）

**User Story:** As a developer, I want an AgentService that encapsulates the "Intent-Driven Dynamic Context" pattern, so that Controller doesn't directly call streamText().

#### Acceptance Criteria

1. THE System SHALL create a new `agent/` submodule at `apps/api/src/modules/ai/agent/`
2. THE Agent submodule directory structure SHALL be:
   ```
   ai/agent/
   ├── index.ts              # 导出 { streamChat, generateChat, getAgent }
   ├── types.ts              # AgentConfig, RuntimeContext, ChatParams
   ├── agents.ts             # createAgent() + 预定义 Agent 配置
   ├── chat.ts               # streamChat(), generateChat() 入口
   ├── router.ts             # classifyIntent() - 意图分类
   └── context.ts            # buildContext() - RuntimeContext 构建
   ```
3. THE `streamChat()` function SHALL be the entry point for streaming AI chat (纯函数)
4. THE `ai.service.ts` SHALL re-export `streamChat` and `generateChat` from `agent/chat.ts`
5. THE `streamChat()` function SHALL implement 5-step flow:
   - Context Building (组装上下文)
   - Intent Classification (意图分类)
   - Mode Switching (获取 Prompt + Tools)
   - streamText Execution (执行 LLM)
   - Lifecycle Hooks (保存历史、提取偏好)
6. THE System SHALL define 5 Modes in `agent.modes.ts`:
   | Mode | Prompt 风格 | Tools |
   |------|------------|-------|
   | CHAT | 暖男闲聊 | 无 |
   | EXPLORE | 导游推荐 | exploreNearby |
   | CREATE | 秘书确认 | createDraft, refineDraft, publishActivity |
   | PARTNER | 中介撮合 | createPartnerIntent, askPreference |
   | MANAGE | 管家汇报 | getMyActivities, cancelActivity |
7. THE `getAgentMode(intent)` function SHALL return Mode-specific Prompt and Tools
8. THE System SHALL NOT use multi-Agent architecture (避免延迟爆炸和 Token 浪费)

### Requirement 14: 架构分层文档化

**User Story:** As a developer, I want the architecture documentation to clearly show the three-layer separation (Brain/Limbs/Knowledge), so that the system design is easy to understand.

#### Acceptance Criteria

1. THE TAD.md SHALL document the Mastra-style three-layer architecture:
   - **Brain (AI Module)**: Agent Orchestrator, Intent Router, Memory Manager
   - **Limbs (Tools Registry)**: createDraft, publishActivity, exploreNearby
   - **Knowledge (RAG Engine)**: Index Service, Search Service
2. THE TAD.md SHALL include a Mermaid diagram showing:
   - API Gateway → Agent Orchestrator → Intent Router → Tools
   - Tools → RAG Controller → Database
   - Activities CRUD → Event → RAG Controller (async indexing)
3. THE TAD.md SHALL update the module directory structure to reflect:
   ```
   /apps/api/src/modules/
   ├── activities/         # 业务逻辑：CRUD、状态流转
   ├── ai/                 # AI 核心模块
   │   ├── agent/          # [NEW] Agent 封装层
   │   ├── rag/            # [NEW] RAG 子模块
   │   ├── intent/         # 意图识别
   │   ├── memory/         # 上下文管理
   │   └── tools/          # Tools 定义 (调用 rag)
   └── ...
   ```


### Requirement 15: 破坏性 API 升级

**User Story:** As a solo developer, I want to perform breaking API changes to achieve a cleaner architecture, so that I don't accumulate technical debt.

#### Acceptance Criteria

1. THE System SHALL allow breaking changes to API interfaces (不需要向后兼容)
2. THE old `/activities/nearby` endpoint SHALL be replaced by new RAG-based search
3. THE new search endpoint SHALL be:
   ```typescript
   POST /rag/search
   Body: {
     semanticQuery: string;
     filters: {
       location?: { lat: number; lng: number; radiusInKm: number };
       timeRange?: { start: Date; end: Date };
       type?: string;
     };
     limit?: number;
   }
   ```
4. THE AI Tools SHALL be simplified:
   - REMOVE: any keyword-based search tools
   - UPGRADE: `exploreNearby` to use RAG exclusively
5. THE frontend (miniprogram) SHALL regenerate SDK via `bun gen:api` after API changes
6. THE System SHALL NOT maintain dual search paths (no "if semantic then RAG else SQL" logic)

### Requirement 16: 数据迁移脚本

**User Story:** As a developer, I want a migration script to upgrade existing data to the new schema, so that old activities become searchable in the new system.

#### Acceptance Criteria

1. THE System SHALL provide `scripts/upgrade-v4.5.ts` migration script
2. THE Script SHALL:
   - Add pgvector extension if not exists
   - Add embedding column to activities table
   - Create HNSW index on embedding column
   - Backfill embeddings for all existing activities
3. THE Script SHALL be idempotent (safe to run multiple times)
4. THE Script SHALL log progress: total, processed, skipped, errors
5. THE Script SHALL handle rate limits (batch processing with delays)
6. THE Script SHALL support `--dry-run` flag for preview

### Requirement 17: 清理旧代码

**User Story:** As a developer, I want to remove deprecated code paths, so that the codebase stays clean and maintainable.

#### Acceptance Criteria

1. THE System SHALL remove old keyword-based search logic from activities module
2. THE System SHALL remove any "compatibility shim" code
3. THE System SHALL consolidate all search logic into RAG module
4. THE exploreNearby Tool SHALL have a single code path (RAG-based)
5. THE codebase SHALL NOT contain commented-out old code
6. THE TAD.md SHALL be updated to remove references to deprecated patterns

## Migration Strategy

### Phase 1: Database Upgrade
1. Run migration to add pgvector extension
2. Add embedding column to activities table
3. Create HNSW index

### Phase 2: RAG Module Implementation
1. Create `modules/rag/` with service, types, utils
2. Implement indexActivity() and search() methods
3. Write unit tests for RAG service

### Phase 3: API Upgrade (Breaking)
1. Create new `POST /rag/search` endpoint
2. Update exploreNearby Tool to use RAG service
3. Remove old `/activities/nearby` endpoint
4. Regenerate frontend SDK

### Phase 4: Data Migration
1. Run backfill script for existing activities
2. Verify all activities have embeddings
3. Test semantic search with real data

### Phase 5: Cleanup
1. Remove deprecated code
2. Update documentation
3. Final testing
